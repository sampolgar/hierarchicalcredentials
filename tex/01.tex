\section{Abstract}
The digital identity landscape is on the cusp of massive adoption, with the EU's eIDAS-2 framework mandating 400 million EU citizens possess interoperable digital identity wallets by September 2025, furthermore, countries such as India, Singapore, Japan and Canada have pre-existing digital identity systems. This unprecedented scale of deployment demands privacy-preserving identity systems that can meet security requirements, be flexible for real-world operational needs, and efficient. In this paper, we show how a privacy-preserving credential system can be designed to simultaneously adhere to system security and accountability properties while maintaining user privacy and complex identity support. 
Our system demonstrates solutions for outstanding problems in Decentralized Identity, namely, how to design a system that enables privately linking credentials from multiple issuers and presenting credentials together efficiently by benchmarking our methods to those of the state of the art in this domain.

\section{Introduction}

\textbf{Main Research Question: }

\textit{How can credential systems be designed to maintain accountability and sybil resistance with privacy and unlinkability. }

\noindent \textbf{Sub Research Questions}

\textit{How can we design a privacy-preserving credential system that enables hidden linking of government and private credentials while maintaining provable provenance and revocability?}

\textit{How can we efficiently combine credentials for verification while retaining their security properties}


\subsubsection{Contributions}
We present a comprehensive privacy-preserving decentralized identity system that improves upon the state of the art, offering accountable privacy, complex identity support, decentralization, and efficient implementation.
\begin{itemize}
    
    \item Support for privately linked "context/pairwise" credentials from different issuers, enabling complex identity verification scenarios and accountability. 
    
    \item We show protocols for issuance and verification scenarios and benchmark them

    \item An efficient, customized implementation of PS signatures over commitments for anonymous credentials, with concrete performance benchmarks showing improvements over the existing approach
    
    \item Sybil resistance and Revocation with full system privacy

    \item a system that covers all the features in the comparison table \ref{tab:comparison} 
    
    \item A complete system implementation in Rust using the Arkworks library, demonstrating practical feasibility (not finished)
    
\end{itemize}





% When answering, discuss how they motivate, in which setting and why it’s important, and what they’re missing / outstanding work.
% – How used / important is "certified sampling" ?
% – How is it done (if it exists) ?

\subsection{Motivation}

The Internet Identity Workshop discussed a problem space summarised by the following problems:
\begin{enumerate}
    \item issuing credentials that are both government and privately issued
    \item retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
    \item combining traditional digital identity with decentralized identity
\end{enumerate}

A user has an Identity linked to multiple credentials, such as a driver's license and university card. Users want to authenticate with various Relying Parties (Verifiers) without being linked between multiple uses of the same service (e.g. a user verifying multiple credentials with 1 service such as a bank requiring proof of multiple credentials linked to an identity), and between uses of different services (e.g. a user presenting their drivers license for age verification on multiple services).

Current decentralized identity systems either don't provide this functionality or provide it at the expense of either accountability or privacy. CanDID stores a map between users multi-layered credentials providing a solution to the problem at the expense of the user's privacy. Other credential systems and pseudonym systems prove equality of hidden attributes in a credential such as name or id, which can more-easily be forged and does not support the hierarchical structure leveraging a highly secure and accountable government identity with not-so secure private credentials.

\newpage




\section{Related Work}
\textbf{Decentralized Identity}
In DID, a user has multiple credentials in a "digital wallet" and decides how to use them and which information can be revealed. The credentials are issued to an individuals identifier and publicly verified on a decentralized system, improving interoperability and aiming to break from the platform lock-in effects of the current centralized identity systems. Unlike using physical credentials, this provides a unique step-forwards in digital identity management as organizations can verify a user's information more thoroughly at a wider breadth. E.g. multiple credentials from different issuers, preventing the use of credential theft from a single credential. DID has made great progress towards its goals of decentralizing identity management from single providers like Google and Microsoft with projects like DID foundation, Sovrin, W3C. However, at the expense of Privacy.

\noindent \textbf{Anonymous Credentials}
Anonymous Credentials are a long line of orthogonal work with the goal of providing privacy/anonymity to online interactions, These are now deployed in a number of real-world systems (U-Prove, Idemix, PrivacyPass).  
The line of work has improved with features, efficiency, and expressiveness throughout time. 
Abstractly, they provide private protocols to prove information on committed attributes. 
Pairing-based blind signatures enabled efficient multi-show credentials (CL, PS, BBS+).
Other constructions are based on (chase's MAC's, etc) 
Further work was done to the Anonymous Credential primitive to support delegation, update, and pseudonyms and may also require incorporating other cryptographic primitives to enable revocation, auditing, tracing, and sybil resistance. 

\noindent \textbf{Credential Oracles}


\noindent \textbf{Accountable Privacy}
In a parallel industry, fully private financial systems like zcash, monero, and tornado cash where blockchain users can exploit and misuse the system is a big problem and will prevent governments and organisations to deploy private preserving techniques. Innovations in Identity often follow those in financial systems, (Chaum's e-cash and blind signatures, DAC and ZCash for example) as they share similar motivations and infrastructure, spending a coin anonymously is analogous to using an identity anonymously. Therefore, advancements in the field of Accountable Privacy (UTT, other examples), a series of techniques and protocols that balance the tradeoffs between privacy and accountability in financial systems, can inspire and motivate private identity systems.

\noindent \textbf{Privacy Preserving Decentralized Identity Systems}
CanDID proposed a privacy-preserving decentralized identity system achieving Sybil Resistance, Accountability. 
They defined a system architecture that has been extended in many different directions, such as \cite{wang2023hades, rathee_zebra_2022} optimising for blockchain performance and additional private-accountability features. \cite{crites_syra_2024, rabaninejad_attribute-based_nodate} optimize for non-interactivity and minimal stored state with the CanDID threshold committee

\begin{enumerate}
    \item Achieves sybil resistance but at the expense of using heavy MPC
    \item Requires interacting with the committee for issuing each Context Credential
    \item maintain a mapping of users credentials to real-world identity (scalability, privacy, security concern)
    \item Interacting with the committee links different transactions because the credentials rely on public keys and each committee member holds a list of the links between master public key and context credential public key
    \item maintains a (state) mapping between credentials and real-world identities, introducing scale issues and dependencies
    \item The master credential can be used maliciously to get context credentials because there is no key derivation between master and context
\end{enumerate} 

CanDID leaves integrating Decentralized Identity with Anonymous Credentials as open work.

\noindent \textbf{Decentralized Identity with Anonymous Credentials}
The strawman approach to combining Decentralized Identity with Anonymous Credentials replaces the existing credential, usually in the form of a signature over attributes, signed by an identity provider and verifiable with their public key, with a blind signature over attributes, which introduces the accountable privacy problems such as how to issue and verify a credential to an anonymous user, and how to retain accountability of an anonymous user, such are the real-world identity system requirements. 
Compatibility for a decentralized architecture requires decentralized cryptography which has propelled the use of threshold cryptography in anonymous credential schemes and other settings e.g. (Coconut, Threshold BBS+, ...). 


\noindent \textbf{Pseudonym Systems}
There are 2 main models for Pseudonyms. One where the user has a Master Credential and derives pseudonym, or context credentials from the Master Credential. The applications differ; for example, in \textbf{Model 1}, a user may have their Passport as their Master Credential and wish to use it in a different scenario, such as voting for an election. The user will derive, by themselves, a new credential with the context "voting-2024," which will be verified in the same way as the master credential.
\textbf{Model 2} differs in application scenarios. A context credential represents a credential from a different issuer, for example, a driver's license. During Context Credential issuance, a user will present their Master Credential which will be used to verify the identity of a user and to link the 2 credentials together. During context credential verification, the user may be requested to present just their Context Credential, or perhaps in a high-security verification setting, where a user may need to prove attributes in multiple credentials both Master and Context will need to be presented together. We optimize for this setting while \emph{preserving privacy.}



\noindent \textbf{Pseudonym Model 1: Master Credential, One Issuer, derived Pseudonyms}

SyRA and TACT optimize for Non-Interactivity
They also define context differently to us. Which isn't what CanDID defines context as and doesn't work for the same usescases and CanDID was defined for. 

Previous Methods

\noindent SyRA: Sybil-Resilient Anonymous Signatures  with Applications to Decentralized Identity \cite{crites_syra_2024}
1. enables users to "derive" unlinkable, sybil resistant pseudonyms (signatures) for a context e.g. PRF(sk, ctx) without interacting with the issuer
2. does not store a mapping on the issuer
3. Security properties: Sybil resistance in the context. Anonymity: no information is leaked through their nyms or signatures. Proves UC security for unforgeability, Sybil resilience, privacy, and unlinkability
4. SyRA leaves support for Identity Attributes for future work.

Summary: First, a protocol with issuer creates a user with secret key $s$. $s$ generates a context specific pseudonym, or tag $T$ "that attaches itself to a signature"?

\begin{itemize}
    \item Level 1: $Issue_{isk}(s)$: $VRF_{isk}(s) \to T, \pi_{prf}$ such that $\pi_{prf}$ generates the users keys and is symmetric across $\G_1, \G_2$: This algorithm is computed by the issuer with their secret key $isk$ on identity string $s$ Outputs $T = e(g, \tilde{g})^{1/(s + isk)}$ and $\pi_{prf}$ is $usk = g^{1/(s + isk)} \in \G_1$ and $\widehat{usk} = \tilde{g}^{1/(s + isk)} \in \G_2$. Their verify algorithm is the same as the Dodis Yampolskiy and also verifies the asymmetric keys with bilinear pairing.
    \item Level 2: $Sign_{usk, \widehat{usk}}(ctx, m, ivk)$: $VUF_{usk}(ctx) \to T = e(H(ctx), \widehat{usk})$: This is the "sybil resistant signature". Proof of correctness comes from sigma protocol. During the verify protocol, the 
\end{itemize}

Conclusion: SyRA creates a signature scheme where a user can "sign" on $ctx, m$ from their secret key based on a VRF of their identity and the issuer's key. This does not account for Attribute-based credentials.

Attribute-Based Threshold Issuance Anonymous Counting Tokens \cite{rabaninejad_attribute-based_nodate}
What don't they do that we do?
We avoid Groth Sahai proofs - page 26 they refer to proving the signature scheme with GS proofs. 
They use Naor Pinkas Reingold PRF and verify signature with GS proofs. 
They focus only on deriving credentials / pseudonyms from their

\noindent \textbf{Pseudonym Model 2: Master Credential, Multiple Issuers, Different Pseudonyms}
The Pseudonym Model \cite{goos_pseudonym_2000} presents as an interaction between a User, a Certificate Authority (CA), and a Pseudonym Organisation (O). The user's identity is registered to the CA with their keypair $skU, pkU$, receiving a Master Credential to act as a trust anchor for all pseudonyms. With their Master Credential, Users request \emph{unlinkable} Pseudonyms for other organizations by first proving the knowledge of a Master Credential that verifies with the CA, and the pseudonym requested has the same keypair as the Master Credential. Organizations \emph{blindly} issue Pseudonym credentials on the same keypair as the Master Credential.


\begin{itemize}
    \item \textbf{$MasterCredIssue(skU, pkU, identity, skCA) \to CredM$} is an interactive algorithm run by a user and a credential authority with keypair $skCA, pkCA$. The user is known to the CA and shares their identity and a keypair $skU, pkU$. The $CA$ checks the $skU, pkU$ relation and issues $CredM$, a signature $\sigma_{CA} \gets Sign_{skCA}(pkU)$
    
    \item \textbf{$NymGeneration(CredM, pkCA, Nym, skO) \to CredNym$} is an interactive algorithm run by a user and an organization the user wishes to create a pseudonym with. 
    $Nym1$ is a commitment $Com(skU, pkU, r)$ with randomness $r$, $r$ should be unique per pseudonym. 
    $U$ generates a zero-knowledge proof of knowledge of a new pseudonym $Nym1$ with $skU, pkU$ corresponding to $CredM$, $CredM$ verifies correctly, and $pkU, skU$ are related. 
    \[
    \begin{aligned}
    ZKP
    \{ 
        (skU, pkU, r): Nym &= Com(skU, pkU, r) \; \wedge \\
        Verify_{pkCA}(CredM) &= 1 \; \wedge \\ 
        pkU &= g^{skU}
     \}
    \end{aligned}
    \]
    On successful ZKP verification, algorithm outputs $CredNym \gets Sign_{skO}(Nym)$

    \item \textbf{$NymVerify(CredNym, pkO) \to \bit $} is an interactive algorithm run by a user and a verifier. Recall $CredNym$ is a signature over a commitment $Sign_{skO}(Nym)$. The user randomizes $CredNym' \gets CredNym$ and $Nym' \gets Com(skU, pkU, r)$, and in zero knowledge, proves $CredNym$ verifies correctly with respect to the original signature, and the organisation public key
        \[
        \begin{aligned}
        ZKP
        \{  
            (skU, pkU, r, r'): Nym' &= Com(skU, pkU, r') \; \wedge \\
            \exists \; Nym \text{ such that } Verify_{pkO}(Nym) &= 1 \; \wedge \\ 
            Nym &= Com(skU, pkU, r) \; \wedge \\
            pkU &= g^{skU}
        \}
        \end{aligned}
        \]
\end{itemize}






\subsection{Comparison}

\begin{table}
\begin{center}
\caption{Comparison of our construction over previous work.}
\label{tab:comparison}
\begin{tabular}{l|cccccccccc}
Features    & Multi-Issuer & ABC$\footnotemark[1]$.          & unf.          & blind.                & Sybil-resistance  & unlink$\footnotemark[3]$.       & non-transfer$\footnotemark[2]$  &  nym-1  & nym-2$\footnotemark[5]$ &  Revocation \\
\hline
CanDID \cite{maram2021candid}     & \ding{51} & \ding{55}     & \ding{51}     & \ding{51}             & \ding{51}         & \ding{55}     & \ding{55}     & \ding{55} & \ding{51} & \ding{51}\\
SyRA \cite{crites_syra_2024}     & \ding{55}    & \ding{55}     & \ding{51}     & \ding{55}             & \ding{51}         & \ding{55}     & \ding{51}     & \ding{51} & \ding{55}\\
S3ID \cite{rabaninejad_attribute-based_nodate}    & \ding{55}    & \ding{51}     & \ding{51}     & \ding{51}             & \ding{51}         & \ding{51}     & \ding{51}     & \ding{51} & \ding{55} & \ding{55}\\
LRSW \cite{goos_pseudonym_2000}     & \ding{55}    & \ding{55}     & \ding{51}     & \ding{51}             & \ding{55}         & \ding{51}     & \ding{51}     & \ding{55} & \ding{51} & \ding{55}\\
US       & \ding{51}   & \ding{51}     & \ding{51}     & \ding{51}             & \ding{51}         & \ding{51}     & \ding{51}     & \ding{55}$\footnotemark[6]$ & \ding{51} & \ding{51}\\
\end{tabular}
\end{center}
\todonote{Review this}
\vspace{1em}
\footnotesize
$\footnotemark[1]$ Attribute Based Credentials / Anonymous Credential?

\footnotesize
$\footnotemark[2]$ We use the definition of non-transferrable credentials as an "all-in-one" credential system where knowledge of an individual's private key is required for all credentials to prevent a user from transferring 1 credential to be used individually 

\footnotesize
$\footnotemark[3]$ Unlinkability in the same context, i.e. Multi-Show Anonymous Credentials. CanDID is pseudonymous rather than fully anonymous; i.e., the issuer learns a unique pseudonym as the identifier of a user who initiates each query and is associated with that user's CanDID credentials.

\footnotesize
$\footnotemark[4]$ Defines Pseudonyms in the context of a user having a master credential with the ability to derive sybil-resistant, unlinkable context credentials from the master credential

\footnotesize
$\footnotemark[5]$ Defines Pseudonyms in the context of a user having a high-trust/high-security master credential with the ability to be issued sybil-resistant, unlinkable context credentials from different organizations

$\footnotemark[6]$ The model in this paper focuses on nyms$\footnotemark[5]$ however, implementing this functionality with our scheme and primitives requires drop-in addition by extending our Anonymous Credential with 1 attribute and including \cite{crites_syra_2024, rabaninejad_attribute-based_nodate} or techniques from other schemes \cite{damgard_balancing_2020, rathee_zebra_2022, wang2023hades}.
\end{table}


\newpage

\begin{table}
\begin{center}
\caption{Comparison of our construction over previous work.}
\label{tab:comparison}
\begin{tabular}{l|ccccc}
Features    									& Sybil Resistance		& Credential Chaining & M-ABC         & Anonymity     & Revocation\\
\hline
CanDID \cite{maram2021candid}     				& \CIRCLE 	& \Circle     & \Circle     & \Circle		& \CIRCLE\\
SyRA \cite{crites_syra_2024}     				& \CIRCLE    	& \Circle     & \Circle     & \CIRCLE		& \Circle\\
S3ID \cite{rabaninejad_attribute-based_nodate}  & \CIRCLE    	& \CIRCLE     & \CIRCLE     & \CIRCLE		& \Circle\\
Our Work  										& \CIRCLE    	& \CIRCLE     & \CIRCLE     & \CIRCLE		& \CIRCLE\\
\end{tabular}
\end{center}
\end{table}


\begin{table}
\begin{center}
\caption{Comparison of our construction over previous work.}
\label{tab:comparison}
\begin{tabular}{l|ccccc}
Features    									& Sybil Resistance		& Credential Chaining & M-ABC         & Anonymity     & Revocation\\
\hline
CanDID \cite{maram2021candid}     				& \ding{51} 	& \ding{55}     & \ding{55}     & \ding{55}		& \ding{51}\\
SyRA \cite{crites_syra_2024}     				& \ding{51}    	& \ding{55}     & \ding{55}     & \ding{51}		& \ding{55}\\
S3ID \cite{rabaninejad_attribute-based_nodate}  & \ding{51}    	& \ding{51}     & \ding{51}     & \ding{51}		& \ding{55}\\
Our Work  										& \ding{51}    	& \ding{51}     & \ding{51}     & \ding{51}		& \ding{51}\\
\end{tabular}
\end{center}
\end{table}





















\newpage
\section{System Model}
Our identity system involves users, credential issuers, auditors, and credential verifiers. 

\begin{itemize}
    \item \textbf{User: }($U$) a user holds a master credential $Cred_{master}$ and any number of context credentials $Cred_{ctx}$ in their identity wallet. Their $Cred_{master}$ contains 2 unique attributes, an identifier $s$ and a key $k$ and any number of additional attributes. $Cred_{master}$ is a high-security credential issued by a government entity like a digital passport. $Cred_{ctx}$ are credentials issued by any participating credential issuer, for example, a digital driver's license or a bachelor credential issued by the university. 

    \item \textbf{Credential Oracle: } ($CO$) Users interact with Credential Oracles who verify a user's identity and issue digital credentials over their attributes. $CO$'s have a keypair $sk_{CO}, pk_{CO}$
    
    \item \textbf{Credential Issuer: } ($I$) There are 2 types of credential issuers. Credential Oracle $CO$'s verify identity and issue pre-credentials and use their own issuing schemes. In this paper, we assume they all run a rerandomizable anonymous credential. A user's Master Credential $Cred_{master}$ is a high-value credential and thus issued by the threshold committee or nodes of a blockchain. To be issued a Master Credential, a user interacts with the Master Credential Oracle to be first issued a pre-credential, then takes it to the Committee to be issued a Master Credential. $sk_{I}, pk_{I}$

    \item \textbf{Auditor: }($A$) The auditor, also a threshold of nodes, holds the shared secret keys for threshold decryption. The user encrypts their key $k$ with the Auditor's public key $TPKE.Enc_{pkA}(k)$ and shares with the credential oracle during issuance. During Revocation, the oracle provides the encryption, receives $k$ and can revoke accordingly. 

    \item \textbf{Verifier: } ($V$) A verifier is any party wanting to verify a user's credential
    
\end{itemize}


\todonote{below needs updating}
\subsubsection{Syntax of Anonymous Identity System with Sybil Resistance and Revocation}
After public parameter creation, we assume each algorithm receives public parameters as input $\ppar$ 
\begin{itemize}

    \item $\mathsf{Setup}(\secparam) \torand \ppar:$ inputs the security parameter $\lambda$ in unary, outputs system parameters $\ppar$

    \item $\mathsf{OrgKeygen}(\secparam, n, t) \torand \{\osk, \opk, (\osk_1, \dots, \osk_n)\}:$ input the $t$ of $n$ threshold, output $\opk$ the public key, $\vk$ the verification key, and $\sk_i$ the shared secret key for each party.

    \item $\mathsf{UserKeygen}(\secparam) \torand (\mku, \alpha)$ outputs $\mku$ the master key and $\alpha$ the user secret key. 

    \item $\mathsf{ObtainMaster}(\mcm, \UL, \RL, \phi) \torand \mathsf{IssueMaster}$ user inputs their master commitment $\mcm$, the user and revocation lists $\UL, \RL$ and $\phi$ the issuance statement. Outputs are sent to the org running $\mathsf{IssueMaster}$
    
    \item $\mathsf{IssueMaster}(\mcm', \pi_{\rcm} \pi_{\UL}, \pi_{\RL}, \phi) \torand (\sigma, \beta, \UL')$ the org receives the users randomized commitment $\mcm'$, the $\pi_{\mcm}$ the proof $\mcm$ satisfies $\phi$ and the proofs the user is Sybil and isn't revoked. Outputs $\perp$ and cancels if proofs aren't valid, else, outputs $\rcd$ the master credential, $\UL'$ the updated user list, $\beta$ the encrypted user information for the audit committee.

    \item $\mathsf{ObtainContext}(\ccm, \rcd, \UL, \RL, \phi) \torand \mathsf{IssueMaster}$ user inputs their context commitment $\ccm$, the master credential $\rcd$, the user and revocation lists $\UL, \RL$ and $\phi$ the issuance statement for the context. User randomizes $\ccm$, outputs are sent to the org running $\mathsf{IssueContext}$
    
    \item $\mathsf{IssueContext}(\ccm', \pi_{\ccm}, \pi_{\UL}, \pi_{\RL}, \phi)$ 
    the org receives the users randomized context commitment $\ccm'$, $\pi_{\ccm}$ contains proof the context credential contains attribute derived from master cred and satisfies $\phi$, $\pi_{\UL}, \pi_{\RL}$ prove the user is Sybil and isn't revoked. Outputs $\perp$ and cancels if proofs aren't valid, else, outputs $\ccd$ the context credential, $\UL'$ the updated user list.

    \item $\mathsf{Show}(\cd, \cm, \phi, \RL) \to \mathsf{Verify}$ show is run by the user, inputs their commitment $\cm$ and credential $\cm$, $\phi$ the statement to prove and $\RL$ the revocation list, outputs sent to $\mathsf{Verify}$.

    \item $\mathsf{Verify}(\cd', \cm' \pi_i, \phi, \RL) \to \bit$ verify is run by a verifier and takes in $\pi_i$ verification proofs that satisfy the statement $\phi$ and the proves the credential isn't $\in \RL$. Outputs 1 if successful or 0 if failure.

    \item $\mathsf{Revoke}(\RL, \beta) \to \RL'$ revoke is run by the accountability committee who requests the organisation decrypt $\beta$ to find $\mku$ and add required pseudonyms to $\RL$. Returns $\RL'$ the updated revocation list
\end{itemize}



\newpage

\newpage
\section{Issuing}
Write about the registration setting, how a user with a master credential 

\newpage
\section{Usage}
We analyze multiple methods to privately prove two or more credentials are linked together are proving equality of attributes within commitments and proving that a Level2 credential contains a derivation of the Level1 credential, linking the two together in a hierarchy. 
We asymptotically compare the 2 approaches modeled using Pedersen Commitments and Sigma Protocols as used in many popular Anonymous Credential schemes.

\subsection{The Verification Setting}
Our anonymous credential is a multi-attribute, rerandomizable signature over-committed values. We use the Pedersen Commitment scheme, the below analysis is in the context of a user having 2 commitments. $C_1$ is the Master Credential commitment containing a secret key, $C_2$ is the commitment within the Context Credential. 


\subsubsection{Equality of committed string}
This method uses sigma protocol with the same challenge $c$ to prove the response $z_{pid}$ can be used to prove knowledge of the opening of both commitments and thus the string must be the same.
\[
ZKP
    \left\{ 
    (pid, r_1, r_2): C_1 = g_1^{pid} h^{r_1} \wedge C_2 = g_1^{pid} h^{r_2}
    \right\}
\]

\pcb{
\textbf{User} \< \< \textbf{Verifier}  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
pid, r1, r2 \<\< C_1, C_2 \\
a, \rho_1, \rho_2 \sample \mathbb{Z}_q^3 \<\< \\
T_1 := g_1^a h^{\rho_1} \<\< \\
T_2 := g_1^a h^{\rho_2} \< \sendmessageright*{T_1, T_2} \< \\
\< \sendmessageleft*{c} \< c \sample \mathbb{Z}_q \\
z_{pid} = a + c \cdot pid \<\< \\
z_{r_1} = \rho_1 + c \cdot r_1 \<\< \\
z_{r_2} = \rho_2 + c \cdot r_2 \<\< \\
\< \sendmessageright*{z_{pid}, z_{r1}, z_{r2}} \< \\
\<\< g_1^{z_{pid}} h^{z_{r_1}} \stackrel{?}{=} C_1^c \cdot T_1 \\
\<\< g_1^{z_{pid}} h^{z_{r_2}} \stackrel{?}{=} C_2^c \cdot T_2 \\
}

\begin{itemize}
    \item Proving knowledge of openings $(pid, r1)$ and $(pid, r2)$ for commitments $C_1 = g_1^{pid}h^{r1}$ and $C_2 = g_1^{pid}h^{r2}$
    \item Proves equality of $pid$ across both commitments
\end{itemize}


\newpage


\subsection{ZKP Sigma Protocol for proving PRF output in G1}
We have $g^{\frac{1}{m}}$ and $g^m$. We want to prove their relationship is reciprocal. We will use this later when proving the output of the Dodis Yampolskiy VRF $g^{\frac{1}{sk + x}}$
Let $m_1 = m$, and $m_2 = \frac{1}{m}$. Therefore, we can prove that $m_1 \cdot m_2 = 1$ 
\[ 
    \begin{aligned}
        C_1 &= g^{m_1}h^{r_1} \\
        C_2 &= g^{m_2}h^{r_2} \\
        C_3 &= C_1^{m_2}h^{r_3} \\ 
        C_4 &= h^{r_1m_2 + r_3} \\ 
    \end{aligned}
\]

We use $C_1, C_2$ in a zero-knowledge proof protocol to prove the relation with public elements $C_1, C_2, g, h$

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1
    \right\}
\]

\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g^{m_1}h^{r_1}, C_2 = g^{m_2}h^{r_2}$} \\
{\{\rho_i\}_{i=1}^4, \{\beta_i\}_{i=1}^2}  \sample \mathbb{Z}_q^6 \<\< \\
T_1 \gets g^{\beta_1}h^{\rho_1} \<\< \\
T_2 \gets g^{\beta_2}h^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
C_3 \gets C_1^{m_2}h^{r_3} \<\< \\
T_3 \gets C_1^{\beta_2}h^{\rho_3} \<\< \\
r_4 \gets r_1m_2 + r_3 \<\<  \\
C_4 \gets h^{r4} \<\< \\
T_4 \gets h^{\rho_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
z_{m1} = \beta_1 + e \cdot m_1 \<\< \\
z_{r1} = \rho_1 + e \cdot r_1 \<\< \\
z_{m2} = \beta_2 + e \cdot m_2 \<\< \\
z_{r2} = \rho_2 + e \cdot r_2 \<\< \\
z_{r3} = \rho_3 + e \cdot r_3 \<\< \\
z_{r4} = \rho_4 + e \cdot r_4 \<\< \\
\< \sendmessageright*{\{z_{mi}\}_{i=1}^2, \{z_{ri}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g^{z_{m1}} h^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g^{z_{m2}} h^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  C_1^{z_{m2}} h^{z_{r3}}\\
\<\< C_4^e \cdot T_4 \stackrel{?}{=}  h^{z_{r4}}\\
\<\< C_3/C_4 = g \\
}

\subsubsection{Completeness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$ 
\begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag 
\end{align}

Proof of knowledge of exponents $m2, r2$ by opening $C_2$ 
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} g^{z_{m2}} h^{z_{r2}} && \label{eq:ver1} \\
    (g^{m2}h^{r_2})^e \cdot g^{\beta_2}h^{\rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag \\
    g^{e \cdot m2 + \beta_2}h^{e \cdot r_2 + \rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag 
\end{align}


Equality of $m2 \in \{C_2, C_3\}$ proven by equality of responses $g^{z_{m2}}$ used in \eqref{eq:ver1} and \eqref{eq:ver2}
\begin{align}
    C_3^e \cdot T_3 &\stackrel{?}{=} C_1^{z_{m2}} h^{z_{r3}} \notag \\
    (C_1^{m2}h^{r_3})^e \cdot C_1^{\beta_2}h^{\rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \label{eq:ver2} \\
    C_1^{m2 \cdot e + \beta_2}h^{e \cdot r_3 + \rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \notag
\end{align}

Proof of knowledge of exponent $r4$ by opening $C_4$ 
\begin{align}
    C_4^e \cdot T_4 &\stackrel{?}{=} h^{z_{r4}} \notag \\
    (h^{r_4})^e \cdot h^{\rho_4} &\stackrel{?}{=} h^{\rho_4 + e \cdot r_4} \notag \\
    h^{e \cdot r_4 + \rho_4} &= h^{\rho_4 + e \cdot r_4} \notag
\end{align}

Prove that $C_3/C_4 = g$ implies $g^{\frac{m1}{m2}} = 1$ which proves their inverse relation. Recall $C_1 = g^{m_1}h^{r_1}, r_4 = r_1m_2 + r_3$
\begin{align}
    \dfrac{C_3}{C_4} = \dfrac{C_1^{m2}h^{r_3}}{h^{r_4}} = \dfrac{(g^{m_1}h^{r_1})^{m2}h^{r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g^{m_1\cdot m2}h^{r_1\cdot m2 + r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g}{1} = g \notag \\
\end{align}

\subsubsection{Soundness}
\todonote{Sam todo}

\subsubsection{Zero Knowledge}
\todonote{Sam todo}

\subsubsection{Analysis G1 Method}
\begin{itemize}
    \item \textbf{Prover:} 11 $\G_1$ exponentiations, 4 $\G_1$ additions, 6 $\F_p$ multiplications, 6 $\F_p$ additions
    \item \textbf{Verifier:} 11 $\G_1$ exponentiations, 7 $\G_1$ additions/subtractions, 
\end{itemize}




\newpage
\subsection{ZKP Sigma Protocol for proving PRF output with pairing}

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g_1^{m_1}h_1^{r_1} \in \G_1 \wedge C_2 = g_2^{m_2}h_2^{r_2} \in \G_2 \wedge m_1 \cdot m_2 = 1
    \right\}
\]


\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g_1^{m_1}h_1^{r_1}, C_2 = g_2^{m_2}h_2^{r_2}$ } \\
{\{\rho_i\}_{i=1}^2, \{\beta_i\}_{i=1}^2, \{\gamma_i\}_{i=1}^4}  \sample \mathbb{Z}_q^8 \<\< \\
T_1 \in \G_1 \gets g_1^{\beta_1}h_1^{\rho_1} \<\< \\
T_2 \in \G_2 \gets g_2^{\beta_2}h_2^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
\alpha_1 \gets m_1 \cdot m_2 \<\< \\
\alpha_2 \gets m_1 \cdot t_2 \<\< \\
\alpha_3 \gets t_1 \cdot m_2 \<\< \\
\alpha_4 \gets t_1 \cdot t_2 \<\< \\
A_1 \gets e(g_1, g_2) \<\< \\
A_2 \gets e(g_1, h_2) \<\< \\
A_3 \gets e(h_1, g_2) \<\< \\
A_4 \gets e(h_1, h_2) \<\< \\
\pclinecomment{$C_3 = e(C_1, C_2)$} \\
C_3 \in \G_T \gets A_1^{\alpha_1} A_2^{\alpha_2} A_3^{\alpha_3}  A_4^{\alpha_4}\<\< \\
T_3 \in \G_T \gets  A_1^{\gamma_1} A_2^{\gamma_2} A_3^{\gamma_3} A_4^{\gamma_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^3, \{A_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
\{z_{mi} = \beta_i + e \cdot m_i \}_{i=1}^2 \<\< \\
\{z_{ri} = \rho_i + e \cdot r_i \}_{i=1}^2 \<\< \\
\{z_{ai} = \gamma_i + e \cdot \alpha_i \}_{i=1}^4 \<\< \\
\< \sendmessageright*{\{z_{mi}, z_{ri}\}_{i=1}^2, \{z_{ai}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g_1^{z_{m1}} h_1^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g_2^{z_{m2}} h_2^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  A_1^{z_{a1}}A_2^{z_{a2}}A_3^{z_{a3}}A_4^{z_{a4}}\\
\<\< 
}


\newpage
\subsubsection{Completeness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$
    \begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag
    \end{align}

    
Proof of knowledge of exponents $m2, r2$ by opening $C_2$
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} \tilg^{z_{m2}} \tilh^{z_{r2}} && \label{eq:ver2} \\
    (\tilg^{m2}\tilh^{r_2})^e \cdot \tilg^{\beta_2}\tilh^{\rho_2} &= \tilg^{\beta_2 + e \cdot m_2} \tilh^{\rho_2 + e \cdot r_2} \notag \\
    \tilg^{e \cdot m2 + \beta_2}\tilh^{e \cdot r_2 + \rho_2} &= \tilg^{\beta_2 + e \cdot m_2} \tilh^{\rho_2 + e \cdot r_2} \notag
    \end{align}

    
\begin{align}
    C_3 = e(C_1, \tilde{C_2}) = e(g^{m1} h^{r1}, \tilg^{m2} \tilh^{r2}) \notag \\
    = e(g^{m1}, \tilg^{m2}) \cdot e(g^{m1},\tilh^{r2}) \cdot e(h^{r1}, g^{m2}) \cdot e(h_1^{r1}, \tilh^{r2})  \notag \\
    = e(g, \tilg)^{m1\cdot m2} \cdot e(g,\tilh)^{m1 \cdot r2} \cdot e(h, \tilg)^{r1 \cdot m2} \cdot e(h, \tilh)^{r1 \cdot r2}  \notag \\
\end{align}



\begin{itemize}
    \item Prove knowledge of exponents $(m1 \cdot r2), (r1 \cdot m2), (r1 \cdot r2)$ for $C_3$/$e(g,\tilg)$  with respect to base points $e(g,\tilh) e(h, \tilg) e(h, \tilh)$
    \item $C_3$/$e(g,\tilg)$ 
    \item 
\end{itemize}


Prove that $e(g, \tilg)^{(m1 \cdot m2)} = e(g, \tilg)$ by computing $C_4 = e(g,\tilh)^{m1 \cdot r2} \cdot e(h, \tilg)^{r1 \cdot m2} \cdot e(h, \tilh)^{r1 \cdot r2}$, proving the opening and equality of $(m1 \cdot r2), (r1 \cdot m2), (r1 \cdot r2)$ with $C_3$, then proving $C_3/C_4 = e(g, \tilg) \cdot e(g,\tilh) \cdot e(h, \tilg) \cdot e(h, \tilh) $

\subsubsection{Analysis Pairing Method}
\begin{itemize}
    \item \textbf{Prover:} 2 $\G_1$ exp, 2 $\G_2$ exp, 8 $\G_T$ exp, 1 $\G_1$ add, 1 $\G_2$ add, 6 $\G_T$ mul, 12 $\F_p$ mul, 8 $\F_p$ add, 4 pairing
    
    \item \textbf{Verifier:} 3 $\G_1$ exp, 3 $\G_2$ exp, 5 $\G_T$ exp, 2 $\G_1$ add, 2 $\G_2$ add, 4 $\G_T$ mul
\end{itemize}

\subsubsection{Soundness}
\todonote{Sam todo}

\subsubsection{Zero Knowledge}
\todonote{Sam todo}



\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{Prover} & \textbf{Verifier} \\
\hline
\multicolumn{3}{|l|}{\textbf{Commitment Equality Method}} \\
\hline
G1 exponentiations & 4 & 5 \\
G1 additions & 2 & 4 \\
Fp multiplications & 3 & 0 \\
Fp additions & 3 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{G1 VRF Method}} \\
\hline
G1 exponentiations & 11 & 11 \\
G1 additions & 4 & 7 \\
Fp multiplications & 6 & 0 \\
Fp additions & 6 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{Pairing + VRF Method}} \\
\hline
G1 exponentiations & 2 & 3 \\
G2 exponentiations & 2 & 3 \\
G1 additions & 1 & 2 \\
G2 additions & 1 & 2 \\
Fp multiplications & 12 & 0 \\
Fp additions & 8 & 0 \\
GT exponentiations & 8 & 5 \\
GT multiplications & 6 & 4 \\
Pairings & 4 & 4 \\
\hline
\end{tabular}
\caption{Comparison of computational operations between G1 and Pairing methods}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Operation} & \textbf{Time} \\
\hline
Full Pairing & 1.6218 ms \\
Miller Loop & 0.6931 ms \\
Final Exponentiation & 0.9287 ms \\
G1 Mixed Addition (Affine + Jacobian) & 672 ns \\
G1 Point Doubling (2P) & 414 ns \\
G2 Mixed Addition (Affine + Jacobian) & 2143 ns \\
G2 Point Doubling (2P) & 1302 ns \\
\hline
Estimated G1 Scalar Mult (255-bit) & 191.59 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
Estimated G2 Scalar Mult (255-bit) & 606.01 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
\hline
\end{tabular}
\caption{Performance metrics for arkworks BLS12-381 implementation. Scalar multiplication estimates assume naive double-and-add implementation without optimizations.}
\label{tab:arkworks-performance}
\end{table}
\footnotetext{The G1 and G2 scalar multiplication estimates are derived using a naive double-and-add implementation analysis for 255-bit scalars. For a random scalar $k$, we assume approximately 255 doubling operations (one per bit) and 128 addition operations (corresponding to an expected Hamming weight of $\frac{255}{2}$ for a random scalar). The G1 estimate of 191.59$\mu$s is computed as $(255 \times 414\text{ns}) + (128 \times 672\text{ns})$ using the measured doubling and mixed addition timings. Similarly, the G2 estimate of 606.01$\mu$s is computed as $(255 \times 1302\text{ns}) + (128 \times 2143\text{ns})$. These estimates represent upper bounds as they do not account for common optimizations such as windowing methods, NAF (Non-Adjacent Form) representations, or parallel computation strategies.}














\newpage
\newpage
\section{Methods}


% Let $a : \N \mapsto \N \bigcup \{*\}$ and $b : \N \mapsto \N$ be any functions for which $a(\lambda)$ and $b(\lambda)$ are computable in $poly(\lambda)$ time (expect when $a$ takes value $*$).
% % \begin{definition}
% %     A function family $F_{(\cdot)}(\cdot) : \bit^{a(\lambda)} \mapsto \bit^{b(\lambda)}$ is a family of $VRFs$ if there exists a PPT algorithm $Gen$ and deterministic algorithms $Prove$ and $Ver$ such that $Gen(\secparam)$ outputs a pair of keys $(sk, pk)$, $Prove_{sk}(x)$ computes $(y, \pi)$ where $\pi$ is the proof of correctness, and $Ver_{pk}(x,y,\pi)$ verifies that $y = e(g,g)^{1/x+sk}$ using the proof $\pi = g^{1/x+sk}$
% % \end{definition}

\subsection{Pseudo Random Function}
We use the properties of a pseudo-random function to derive the relationship between a master and context credential. The pseudorandomness property ensures the output $y$ is computationally indistinguishable from random and thus hides the relationship between the user's secret key $sk$ and an input $x$ which could be the context of the new credential we want to privately link to.
\[
    PRF_{sk}(x) \to y
\]

\begin{definition}[Pseudo Random Function]
    A PRF is a couple of algorithms $(PRF.Gen, f)$ with key space $\setK$, input space $\setX$ and output space $\setY$ such that 
    \begin{itemize}
        \item $Gen(\secparam) \to (sk): s \sample S$, sets $sk = s$
        \item $f:$ $\mathcal{K} \times \mathcal{X} \to \mathcal{Y}$ is a keyed function family
    \end{itemize}
\end{definition}

The main security property of a $PRF$ is pseudorandomness, which informally states the output should appear random and not be able to be guessed. Formally, defined as

\begin{definition}[Pseudorandomness]
    A couple of PPT algorithms $(PRF.Gen, f)$ is a \textit{Pseudo Random Function} if, for any $\PPT$ adversary $\adv$ there exists a negligible function $\epsilon$ such that 
    \[
    \advantage{}{}[(\adv)] := 
        \left|
    \Pr     \left[ 
                \mathsf{Exp}^{\mathsf{prf}}(\adv) = 1
            \right] - \frac{1}{2}
        \right| \leq \epsilon(\lambda)
    \]
\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{prf}}(\adv)$}{%
        b \sample \bit \\
        \text{Sample } k \sample PRF.Gen(1^{\lambda}) \\
        \text{Sample } f^* \sample \{g : g : \mathcal{X} \to \mathcal{Y}\} \\
        \text{Run } b' \gets \adv^{\oracle_{\mathsf{prf}}}(1^{\lambda}) \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{prf}(x)}$}{%
        \pcif b = 1 \\
        \t \pcreturn f_k(x) \\
        \pcelse \\
        \t \pcreturn f^*(x)
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}


\subsection{Verifiable Random Function}

\subsubsection{Syntax}
\begin{itemize}
    \item $Gen(\secparam) \to (sk, pk):$ samples $s \sample \Zp^*$, sets $sk = s$ and $pk \gets g^s$, returns $(sk, pk)$
    \item $Prove_{sk}(x) \to (y, \pi):$ $y \gets e(g,g)^{1/(x+sk)}$, $\pi \gets g^{1/(x+sk)}$ where $y$ is the $PRF$ output and $\pi$ is the proof of correctness
    \item $Verify_{pk}(x, y, \pi) \to \bit$ to verify $y$ was computed correctly, verify $e(g^x \cdot pk, \pi) = e(g,g)$ and $y = e(g, \pi)$, output 1 for success, 0 for fail
\end{itemize}

\begin{definition}[Verifiable Random Function]

    A PRF is a triplet of $\PPT$ algorithms $(VRF.Gen, VRF.Eval, VRF.Vfy)$ satisfying:
    \begin{enumerate}
        \item Correctness: For any $(pk, sk)$ in the image of $VRF.Gen(\secparam)$ and any $x \in \setX$
        \[
        \begin{aligned}
            (y, \pi) &\gets VRF.Eval_{sk}(x) \\
            1 &\gets VRF.Vfy_{pk}(x, y, \pi)
        \end{aligned}
        \]


    \item Unique Provability: For any $pk$ (not necessarily in the range of $VRF.Gen$, any input $x \in \setX$, pair of outputs $y_0, y_1 \in \setY$ and pair of proofs $\pi_0, \pi_1$ the following holds
    \[
        \begin{aligned}
            1 &\gets VRF.Vfy_{pk}(x,y_0,\pi_0) \\
            1 &\gets VRF.Vfy_{pk}(x,y_1,\pi_1) \\
            y_0 &= y_1
        \end{aligned}
    \]

    \item Pseudorandomness: For any $\PPT$ adversary $\adv$ running the VRF Experiment, there exists a negligible function $\epsilon$ such that 
    \[
         \advantage{}{}[(\adv)] := 
            \left|
        \Pr     \left[ 
                    \mathsf{Exp}^{\mathsf{rnd}}(\adv) \to 1
                \right] - \frac{1}{2}
            \right| \leq \epsilon(\lambda)
    \]
    
    \end{enumerate}

\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{eval}}(\adv)$}{%
        \text{Sample } b \sample \bit \\
        pk, sk \sample VRF.Gen(1^{\lambda}) \\
        \text{set } x^* = \bot \\
        x^* \gets \adv^{\oracle_{\mathsf{eval}}}(pk) \\
        \pcif x^* \text{was previously queried:} \\
        \t \pcreturn 0 \\
        y_0 \sample \setY \\
        (y_1, \pi) \gets VRF.Eval(pk, x^*) \\
        \adv^{\oracle_{\mathsf{eval}}}(sk, y_b) \to b' \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{eval}(x)}$}{%
        \pcif x \neq x^* \\
        \t (y, \pi) \gets VRF.Eval_{sk}(x) \\
        \t \pcreturn (y, \pi) \\
        \pcelse: \pcreturn \bot \\
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}



\subsection{Further Related Work}
\paragraph{S3ID - TaCT}
The S3ID system introduces a novel approach to self-sovereign identity management through a decentralized threshold signing mechanism, where t out of N issuers must participate to prevent Sybil attacks. The system's architecture revolves around three key components: a deduplication mechanism using a unique attribute, the issuance of unlinkable microcredentials bound to a user's secret key through commitments, and the ability to aggregate these into application-specific credentials that preserve privacy while ensuring non-transferability. While the system presents elegant cryptographic solutions for privacy-preserving identity management, including public verifiability and non-interactive credential presentation, it faces practical deployment challenges. The primary limitation stems from its assumption of a single threshold signing group for all attributes, which doesn't align with real-world scenarios where different credentials are issued by distinct authoritative entities such as government agencies, educational institutions, and other organizations. This gap between the cryptographic construction and practical institutional trust models suggests the need for future research into adapting such systems to support differentiated authority over attribute verification while maintaining their privacy and security properties.

\paragraph{credential chaining}
zk-creds enabled credential changing with Groth16 tricks checking wires of G16 proofs from identical commitments. Commitment needs to have attributes in the same location.
PABC enables accumulated credentials showing commitments with the same attribute values and hence can be proven one value is the same across credentials. 
Aggregate credentials generate a single credential from multiple issuer, aggregating all into one credential for efficient show, this is efficient but not ready for real-world implementations. Credentials contain metadata which can't be aggregated, an individual credential can't be revoked from this model.
CanDID 1. credentials are connected via credential pk's the set of connected pk's is public to issuers.
Syra: pseudonyms are derived from 1 credential?

\paragraph{pseudonym}
U-Prove pseudonyms are 1-show. Privacy Pass tokens are essentially pseudonyms. IBM Idemix.
k-TAA extends this to limit the number of times the pseudonym can be used before its not private.