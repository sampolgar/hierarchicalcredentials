\newcommand{\vt}{\mathsf{vt}}
\newcommand{\wx}{\mathsf{wx}}
\newcommand{\wxone}{\mathsf{w_1x}}
\newcommand{\wxtwo}{\mathsf{w_2x}}
\newcommand{\wxhat}{\mathsf{\hat{w}x}}
% \newcommand{\x}{\mathsf{x}}

\newcommand{\acu}{\mathsf{ACU}}
\newcommand{\acusetup}{\mathsf{ACU.Setup}}
\newcommand{\acuadd}{\mathsf{ACU.Add}}
\newcommand{\acudel}{\mathsf{ACU.Del}}
\newcommand{\acuvermem}{\mathsf{ACU.VerMem}}
\newcommand{\acuvernonmem}{\mathsf{ACU.VerNonMem}}


\newcommand{\rev}{\mathsf{REV}}
\newcommand{\revsetup}{\mathsf{REV.Setup}}
\newcommand{\revrevoke}{\mathsf{REV.Revoke}}
\newcommand{\revtokengen}{\mathsf{REV.TokenGen}}
\newcommand{\revtokenver}{\mathsf{REV.TokenVer}}

\newcommand{\rt}{\mathsf{rt}}

% \newcommand{\tilcm}{\tilde{\mathsf{cm}}}
\newcommand{\tilcm}{\tilde{cm}}


\newcommand{\mb}{\textbf{m}}
\newcommand{\gb}{\textbf{g}}
\newcommand{\tilgb}{\tilde{\textbf{g}}}
\newcommand{\yb}{\textbf{y}}
\newcommand{\rd}{\Delta_r}
\newcommand{\td}{\Delta_t}
\newcommand{\ud}{\Delta_u}


\subsection{Commitment}
\subsubsection{Syntax}
\begin{itemize}
    \item $CM.Setup(\secparam, n) \to ck$: Sample $g \sample \G_1, \tilg \sample \G_2$. Sample $\yb \sample \Z_p^{n}$ and compute $(\gb, \tilgb) \gets (g^{\yb}, \tilg^{\yb})$. Output $ck \gets (g, \gb, \tilg, \tilgb)$
    
    \item $CM.Com_{ck}(\mb, r) \to (\cm, \tilcm):$ Parse $ck$ as $(g, \gb, \tilg, \tilgb)$ and $\mb$ as $(m_1, \dots, m_{\ell})$, return $(\cm, \tilcm)$ as $(\gb^{\mb}g^r, \tilgb^{\mb}\tilg^r)$

    \item $CM.Rerand_{ck}((\cm, \tilcm), \rd) \to (\cm', \tilcm'):$ Parse $ck$ as $(g, \gb, \tilg, \tilgb)$. Compute $(g^{\rd}, \tilg^{\rd})$ and return $(\cm', \tilcm')$ as $(\cm \cdot g^{\rd}, \tilcm' \cdot \tilg^{\rd})$
\end{itemize}

\subsubsection{Construction}

\begin{itemize}
    \item $CM.Setup(\secparam, n) \to ck:$ The setup Algorithm generates the commitment key $ck$. Samples $(g, \tilg) \sample \G_1^* \times \G_2^*$ and $n$ scalars $y_i \gets \Z_p$, $Y_i \gets g^{y_i}$, and $\tily_i \gets \tilg^{y_i}$ $\forall \; 1 \leq i \leq n;$ such that $Y_i = g_1^{y_1}\dots g_n^{y_n}$ and $\tily_i = \tilg_1^{y_1}\dots \tilg_n^{y_n}$. Outputs $ck$ a tuple $(g, Y_i, \tilg, \tily_i)$ with commitment keys in both $\G_1$ and $\G_2$ where $e(Y_i,\tilg) = e(g,\tily_i)$

    \item $CM.Com_{ck}(\{m_i\}^n_{i=1}) \to (cm, \tilcm):$ to commit to $n$ messages $m_1, \dots, m_n$, the committer samples $r \sample \Zp$, and parses $ck$ as $(g, Y_i, \tilg, \tily_i)$ and commits to $\{m_i\}^n_{i=1}$ over dual commitments in $\G_1$ and $\G_2$. Computes $g^r, \tilg^r$, Commits to $\{m_i\}^n_{i=1}$ with respect to $ck$ such that $\cm \gets g_1^{m_1}\dots g_n^{m_n} g^r$ and $\tilcm \gets \tilg_1^{m_1} \dots \tilg_n^{m_n}\tilg^r$ Then outputs $(\cm, \tilcm)$ where the equality of commitments can be verified by pairing $e(\cm, \tilg) = e(g, \tilcm)$
    
    \item $CM.Rerand_{ck}((\cm, \tilcm), \rd) \to (\cm', \tilcm'):$ To rerandomize the commitment, the last element $g, \tilg$ is randomized with $\rd$. Compute $g^{\rd}, \tilg^{\rd}$, Compute $\cm'$ = $\cm \cdot g^{\rd}$ as $g_1^{m_1}\dots g_n^{m_n} g^r \cdot g^{\rd}$ which will equal $g_1^{m_1}\dots g_n^{m_n} g^{r + \rd}$ and equivalently for $\tilcm'$. Return the rerandomized commitments $(\cm', \tilcm')$
    
\end{itemize}






\subsection{PS Signature}
\subsubsection{Syntax}
\begin{itemize}
    \item $PS.KeyGen(\secparam, \ck) \to (\sk, \vk):$ Parse $\ck$ as $ck \gets (g, \gb, \tilg, \tilgb)$. Sample $x \sample \Zp$, set $(\sk, \vk) \gets (g^x, \tilg^x)$

    \item $PS.Sign_{ck}(\sk, \cm) \to \sigma:$ Parse $\ck$ as $\gets (g, \cdot, \tilg, \cdot)$ Sample $u \sample \Zp$, compute $\sigma_1 \gets g^u$, $\sigma_2 \gets (\sk \cdot \cm)^u$
     and return $\sigma \gets (\sigma_1, \sigma_2)$

     \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma': $ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

     \item $PS.Verify_{ck, vk}(\sigma, (\cm, \tilcm)) \to \bit: $ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$
     
\end{itemize}
\subsubsection{Construction}
\begin{itemize}
    \item $PS.KeyGen_{\ck}(\secparam) \to (\sk, \vk):$ The PS Signature KeyGen algorithm is parameterized by the corresponding commitment key $\ck$. The Signer retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, samples secret $x \sample \Zp$, sets $X \gets g^x$ and $\tilx \gets \tilg^x$, sets $\sk$ as $(g, X)$ and the public verification key $\vk$ as $(\ck, \tilx)$ and returns $(\sk, \vk)$

    \item $PS.Sign_{\sk}(\cm) \to \sigma: $ The signing algorithm signs the commitment. Retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, Samples $u \sample \Zp$, Computes $\sigma_1$ as $g^u$ and $\sigma_2 \gets (X \cdot \cm)^u$ both are notably in $\G_1$ and thus $(X \cdot \cm)^u$ = $(g_1^{m_1u}\dots g_n^{m_nu}g^{xu+ru})$. Returns $\sigma \gets (\sigma_1, \sigma_2)$    

    \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma':$ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

    \item $PS.Verify(\sigma, (\cm, \tilcm)) \to \bit:$ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$

\end{itemize}


\subsection{PS Signature over Commitment Construction}
\begin{itemize}
    \item $PS.Rerand_{ck,vk}(\sigma, \rd, \ud) \to \sigma'$: Rerandomization of the signature must preserve the algebraic properties of the commitment itself to allow the commitment to be used for zero knowledge proof protocols. To do so, the commitment is re-randomized with the random factor $\rd$ such that a commitment and signature pair 

\end{itemize}


\[
\begin{aligned}
    PS.KeyGen_{\ck}(\secparam)\\
    sk \gets g^x, vk \gets \tilg^x \\
 \end{aligned}
\] 


\[
\begin{aligned}
    CM.Com_{ck}(m_1, m_2; r) \\
    cm(g_1^{m_1} g_2^{m_2}g^r), \; ck = (g, g_1^{y_1}g_2^{y_2}) \\
 \end{aligned}
\]    

\[
\begin{aligned}
    PS.Sign_{sk}(cm) \to& (g^u, (X \cdot cm)^u) = \\
        &(g^u, (g^x \cdot g_1^{m_1} g_2^{m_2}g^r)^u) =\\
        &(g^u, (g_1^{m_1} g_2^{m_2}g^{x+r})^u)  =\\
        &(g^u, (g_1^{u \cdot m_1} g_2^{u \cdot m_2}g^{u(x+r)})) = (\sigma_1, \sigma_2)\\      
 \end{aligned}
\] 

\[
\begin{aligned}
    PS.Verify_{ck,\vk}(\sigma, \cm) \to \bit =\\
    e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm) = \\
    e(g_1^{u \cdot m_1} g_2^{u \cdot m_2}g^{u(x+r)}, \tilg) = e(g^u, \tilg^x \cdot \tilg_1^{m_1} \tilg_2^{m_2}\tilg^r) \\
        e(g_1^{u \cdot m_1} g_2^{u \cdot m_2}g^{u(x+r)}, \tilg) = e(g^u, \tilg_1^{m_1} \tilg_2^{m_2}\tilg^{x + r}) \\
        e(g_1g_2g, \tilg)^{u(m_1 + m_2 + x + r)} = e(g, \tilg_1\tilg_2\tilg)^{u (m_1 + m_2 + x + r)} \\
 \end{aligned}
\] 

\[
\begin{aligned}
        PS.Rerand(\sigma, \rd, \ud) \to&  (\sigma_1', \sigma_2') \\
        \sigma_1' &= (g^u)^{\ud} = g^{u \cdot \ud} \\
        \sigma_2' &= (\sigma_2 \cdot \sigma_1^{\rd})^{\ud} \\
        &   = (g_1^{u \cdot m_1} g_2^{u \cdot m_2}g^{u(x+r)} \cdot (g^u)^{\rd})^{\ud} = \\
        &   = (g_1^{u \cdot m_1} g_2^{u \cdot m_2}g^{u(x+r) + u \cdot \rd})^{\ud} = \\
        &   = (g_1^{u \cdot \ud \cdot m_1} g_2^{u \cdot \ud \cdot m_2}g^{u \cdot \ud (x+r) + u \cdot \ud \cdot \rd}) \\
        &   = (g_1^{m_1} g_2^{m_2}g^{x+r + \rd})^{(u \cdot \ud )} \\
        (\sigma_1', \sigma_2') &   = (g^{u \cdot \ud}, (g_1^{m_1} g_2^{m_2}g^{x+r + \rd})^{(u \cdot \ud )}) \\
 \end{aligned}
\]

To work with the rerandomized signature, the Commitment Scheme must be rerandomized with the same blinding factor $\rd$ 
\[
    CM.Rerand(\cm, \rd) \to cm'(g_1^{m_1} g_2^{m_2}g^{r+\rd})
\]


\[
\begin{aligned}
    PS.Verify_{ck,\vk}(\sigma', \cm') \to \bit =\\
    e(\sigma_2', \tilg) &= e(\sigma_1', \vk \cdot \tilcm) = \\
    e((g_1^{m_1} g_2^{m_2}g^{x+r + \rd})^{(u \cdot \ud )}), \tilg) &= e(g^{u \cdot \ud}, \tilg^x \cdot \tilg_1^{m_1} \tilg_2^{m_2}\tilg^{r + \rd}) = \\
    e((g_1^{m_1} g_2^{m_2}g^{x+r + \rd})^{(u \cdot \ud )}), \tilg) &= e(g, \tilg_1 \tilg_2 \tilg)^{{u \cdot \ud}(m_1 + m_2 + x + r + \rd)} = \\
 \end{aligned}
\] 
% verify with updated commitment

















% \subsection{Revocation}
% Credential revocation is a fundamental challenge in identity management systems. While credentials grant users access to services, there must be mechanisms to invalidate them when necessary. Since the introduction of public key infrastructure, numerous solutions have been proposed to handle certificate revocation such as time-based expiration, usage limits (k-times use), and revocation lists. In the latter approach, a trusted authority manages a whitelist of valid credentials or blacklist of revoked ones, requiring users to prove their credential status with respect to the list.

% The challenge becomes more complex in privacy-preserving systems as users must be able to prove revocation status without revealing the credential or its attributes. Furthermore, the revocation list should not leak information about which credentials are valid or revoked. 

% \subsubsection{Revocation Scheme}
% A revocation scheme enables efficient proofs of credential validity while maintaining privacy of the revocation status. The scheme consists of a revocation authority that manages the revocation state, protocols for revoking credentials, and methods for users to prove their credentials remain valid. A privacy-preserving revocation scheme must satisfy several properties:

% \begin{itemize}
%     \item Privacy: Users can prove their credential's status without revealing the credential
%     \item Unlinkability: Multiple proofs by the same user cannot be linked
%     \item Efficiency: Proofs should be succinct and verification efficient
%     \item Dynamic Updates: The system supports real-time credential revocation
% \end{itemize}

% \paragraph{Syntax}
% A revocation scheme consists of the following algorithms:

% \begin{itemize}
%     \item $\revsetup(\secparam) \torand (\ppar, \sk, \pk, \vt):$ Given security parameter $\secparam$, generates system parameters $\ppar$, authority's secret key $\sk$, public key $\pk$, and initial revocation state $\vt$
    
%     \item $\revrevoke(\sk, \vt, \cred) \to (\vt', \text{RI}):$ Revokes credential $\cred$, updates revocation state from $\vt$ to $\vt'$, and outputs revocation information RI
    
%     \item $\revtokengen(\cred, \vt, \text{RI}) \to \rt:$ Generates a revocation token $\rt$ for credential $\cred$ using the current revocation state $\vt$ and revocation information RI
    
%     \item $\revtokenver(\vt, \cred, \rt) \to \bit:$ Verifies revocation token $\rt$ for credential $\cred$ against revocation state $\vt$
% \end{itemize}




% \subsubsection{Security Definition}

% \newpage


% % Construction


% \subsubsection{Accumulator}
% An accumulator allows for compact representation of a set while enabling efficient proofs of membership. Our construction uses a universal accumulator that supports both membership and non-membership proofs. The accumulator maintains a constant-size value regardless of the number of elements in the set, while allowing elements to be dynamically added and removed. For each element, the system can generate succinct witnesses that prove either membership or non-membership in the accumulated set.



% \subsubsection{Syntax}
% An accumulator $\acu$ is a set of $\PPT$ algorithms $\acu = \mathsf{Setup, Add, Del, VerMem, VerNonMem}$. 
% \begin{itemize}
%     \item $\acusetup(\secparam) \torand \ppar, \sk, \pk, \vt:$ generates system parameters, takes security parameter $\secparam$ as input, outputs system parameters $\ppar$, secret key $\sk$, public key $\pk$, and initial accumulator value $\vt$
    
%     \item $\acuadd(\sk, \vt, \x) \to (\vt', \wx):$ adds element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, and membership witness $\wx$
    
%     \item $\acudel(\sk, \vt, \x) \to (\vt', \wxhat):$ Deletes element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, non-membership witness $\wxhat$ 
    
%     \item $\acuvermem(\vt, \x, \wx) \to \bit:$ verifies membership, takes current accumulator value $\vt$, element $\x$, witness $\wx$ as input. Outputs accept/reject
    
%     \item $\acuvernonmem(\vt, \x, \wxhat) \to \bit:$ Verifies non-membership, takes current accumulator value $\vt$, element $\x$, non-member witness $\wxhat$ as input. Outputs accept/reject
% \end{itemize}

%  with additional witness operations $\mathsf{MemWitUpOnAdd/Del, NonMemWitUpOnAdd/Del}$ 