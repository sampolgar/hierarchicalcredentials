% https://cseweb.ucsd.edu/~mihir/cse208-Wi20/main.pdf

\section{Preliminaries and Assumptions}
\subsubsection{Notation}
A probabilistic polynomial time algorithm $\algo(\ins) \rightarrow \out$ receives an input $\ins$ and returns an output $\out$. $r \getsrand \Zp$ r is sampled uniformly from the set of field elements modulo $p$,  $h \gets y$ is a deterministic assignment. $[n]$ denotes a sample space of $\{1,\dots,n\}$. We assume type 3 bilinear pairings, $e: \G_1 \times \G_2 \to \G_t$ over groups of prime order $p$, $g, \tilde{g}$ are uniformly chosen generators for $\G_1, \G_2$ such that $e(g, \tilde{g}) = g_t$. We use bold variables to denote vectors as \vect{m} = $[m_1, \dots, m_{\ell}]$, \textbf{g} $\in \G^{\ell}$, \textbf{x} $\in \Z_p^{\ell}$, $\textbf{g}^{\textbf{x}}$ = $\sum\nolimits_{i=1}^\ell g_i^{x_i}$. We use multiplicative notation for $\G$ points i.e. $g^k = g \cdot g \;  (k \text{ times})$


\begin{definition}[Negligible Function]
    A function $\mu : \mathbb{N} \to \mathbb{R}$ is called negligible if for every positive polynomial $p(\cdot)$, there exists a value $N \in \mathbb{N}$ such that for all $n \geq N$ $\mu(n) < \frac{1}{p(n)}$
    
    \end{definition}
    
    % \begin{remark}
    % A classic example of a negligible function is $f(x) = 2^{-x}$, or any function that approaches zero faster than the reciprocal of any polynomial as its input grows.
    
    % Negligible functions are ubiquitous in cryptography, particularly in security definitions. They are used to describe probabilities that are so small that they can be effectively treated as zero in practice. Since it's often impossible to achieve absolute zero probability for certain events (like breaking a cryptosystem), describing such probabilities as "negligible" provides a rigorous way to state that they are as close to zero as practically matters in cryptographic contexts.
    % \end{remark}


%     \begin{definition}[Computational Indistinguishability] \\
%         Let $X = \{X(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}$ and $Y = \{Y(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}$ be two probability ensembles, where:
%         \begin{itemize}
%             \item Each ensemble is an infinite sequence of random variables
%             \item $a \in \{0,1\}^*$ represents parties' inputs
%             \item $n \in \mathbb{N}$ represents the security parameter
%         \end{itemize}
        
%         $X$ and $Y$ are said to be computationally indistinguishable, denoted by $X \stackrel{c}{\equiv} Y$, if for every non-uniform polynomial-time algorithm $D$ (called a distinguisher), there exists a negligible function $\mu(\cdot)$ such that for every $a \in \{0,1\}^*$ and every $n \in \mathbb{N}$:
        
%         \[ |\Pr[D(X(a,n)) = 1] - \Pr[D(Y(a,n)) = 1]| \leq \mu(n) \]
        
%         \end{definition}
        
%         \begin{remark}
%         This definition captures the idea that no efficient algorithm can tell the difference between samples from $X$ and samples from $Y$ with non-negligible probability. The term "non-uniform" allows the distinguisher $D$ to have hard-coded advice that may depend on the input length, potentially making it more powerful.
%         \end{remark}


\begin{definition}[Bilinear map]
    Let $\mathbb{G}_1$, $\mathbb{G}_2$ and $\mathbb{G}_T$ be cyclic groups of prime order $p$, where $\mathbb{G}_1$ and $\mathbb{G}_2$ are multiplicative and $\mathbb{G}_T$ is multiplicative. Let $g$ and $h$ be generators of $\mathbb{G}_1$ and $\mathbb{G}_2$, respectively. We call $e : \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ a bilinear map or pairing if it is efficiently computable and the following holds:
    
    \textbf{Bilinearity:} $e(g^a, \tilde{g^b}) = e(g, \tilde{g})^{ab} \quad \forall a,b \in \mathbb{Z}_p$.
    
    \textbf{Non-degeneracy:} $e(g, \tilde{g}) \neq 1_{\mathbb{G}_T}$, i.e., $e(g, \tilde{g})$ generates $\mathbb{G}_T$.
    
   \noindent If $\mathbb{G}_1 = \mathbb{G}_2$, then $e$ is symmetric (Type-1) and asymmetric (Type-2 or 3) otherwise. For Type-2 pairings, there is an efficiently computable isomorphism $\Psi : \mathbb{G}_2 \rightarrow \mathbb{G}_1$ but none from $\mathbb{G}_1 \rightarrow \mathbb{G}_2$; for Type-3 pairings, no efficiently computable isomorphisms between $\mathbb{G}_1$ and $\mathbb{G}_2$ are known. Type-3 pairings are currently the optimal choice in terms of efficiency for a given security level.
\end{definition}

\begin{definition}[Commitment scheme]
    A commitment scheme is a tuple $(\mathsf{Setup}, \mathsf{Commit}, \mathsf{Open})$ of PPT algorithms where:
    
    \begin{itemize}
        \item $\mathsf{Setup}(1^\lambda) \to \mathsf{ck}$ takes security parameter $\lambda$ (in unary) and generates the commitment key $\mathsf{ck}$;
        
        \item $\mathsf{Commit}_{\mathsf{ck}}(m) \to (\cm, r)$ obtains commitment $\cm$ from secret message $m$ and an opening key $r$ which may be the randomness used in the computation.
        
        \item $\mathsf{Open}_{\mathsf{ck}}(\cm; m, r) \to b \in \{0, 1\}$ verifies the opening of the commitment $\cm$ to the message $m$ provided with the opening hint $r$, outputting a decision as to whether $\cm$ commits to $m$. 
    \end{itemize}
\end{definition}

\begin{definition}[Secret Sharing]
    A $(t,n)$ secret sharing scheme $\mathsf{SS}$ is a tuple of $\PPT$ algorithms $(\mathsf{Share}, \mathsf{Combine})$ over message space $x \in X$:
    \begin{itemize}
        \item $\mathsf{Share}^{t,n}(x, r) \torand ([x]_1, \dots, [x]_n)$ takes input $x \in X$, randomness $r$ and outputs $n$ shares $([x]_1, \dots, [x]_n)$
        \item $\mathsf{Combine}^{t,n}([x]_i, \dots, [x]_t) \to x'$ takes a threshold of secret shares $[x]_i$ for $i > t$ as input and combines to form $x'$ the representation of the original message $x' \in X$
    \end{itemize}
\end{definition}

\begin{definition}[Threshold Public-Key Encryption]
A Threshold Public-Key Encryption Scheme $\mathsf{TPK}$ is a set of $\PPT$ algorithms $\mathsf{(KeyGen, Enc, Dec, Verify, Combine)}$ over $\messagespace$: 
    \begin{itemize}
        \item $\mathsf{TPK.Setup}(\secparam, n, t) \torand \{\pk, \vk, (\sk_1, \dots, \sk_n)\}:$ input the $t$ of $n$ threshold, output $\pk$ the public key, $\vk$ the verification key, and $\sk_i$ the shared secret key for each party.
        \item $\mathsf{TPK.Enc}(\pk, m, \rho) \torand \beta:$ input message $m$ and randomness $\rho$, output encryption $\beta$
        \item $\mathsf{TPK.Dec}(\beta, \sk_i)) \to m_i:$ each party decrypts $\beta$ with their shared secret key $\sk_i$
        \item $\mathsf{TPK.Verify}(\pk, \vk , m_i) \to  \bit:$ input $\pk, \vk$ and share of $m_i$, verify $m_i$ was computed correctly from $\pk, \vk$
        \item $\mathsf{TPK.Combine}(\pk, \vk, {m_i}_{i \in \setspace \subseteq [n] s.t. |\setspace| \geq t + 1}) \to m:$ recovers message $m$ given $t + 1$ partial decryptions which verify successfully
    \end{itemize}
\end{definition}

\begin{definition}[Identity Based Encryption]
insert IBE here
\end{definition}

% \begin{definition}[Homomorphism]
%     Let $G$ and $H$ be groups. A function $\phi: G \to H$ is called a \textit{homomorphism} if it preserves the group operation. Specifically, for any elements $a, b \in G$, the following equation holds:
    
%     \[\phi(a \ast b) = \phi(a) \circ \phi(b)\]
    
%     where $\ast$ denotes the group operation in $G$ and $\circ$ denotes the group operation in $H$.
%     \end{definition}
    
%     \begin{remark}
%     Note that $\phi$ is not required to be injective (one-to-one) or surjective (onto).
%     \end{remark}
    
%     \begin{definition}
%     For a homomorphism $\phi: G \to H$, the \textit{image} of $\phi$ is defined as:
    
%     \[\operatorname{Im}(\phi) = \phi(G) = \{\phi(g) : g \in G\} \subseteq H\]
%     \end{definition}

%     \begin{definition}[Image of homomorphism]
%         For a homomorphism $\phi: G \to H$, the \textit{image} of $\phi$ is defined as:
        
%         \[\operatorname{Im}(\phi) = \{h \in H \mid \exists g \in G \text{ such that } \phi(g) = h\}\]
        
%         \end{definition}

%         \begin{remark}
%             The image of a homomorphism $\phi: G \to H$ can be thought of as the "landing spot" in $H$ for elements coming from $G$. It's the subset of $H$ that includes all possible outputs when $\phi$ is applied to any element in $G$. In essence, $\operatorname{Im}(\phi)$ tells us which elements of $H$ are "reachable" through $\phi$ from some element in $G$.
%         \end{remark}