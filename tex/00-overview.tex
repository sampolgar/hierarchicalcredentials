\newcommand{\user}{\mathsf{U}}
\newcommand{\uri}{\mathsf{URI}}
\newcommand{\expiry}{\mathsf{exp}}
\newcommand{\idp}{\mathsf{IDP}}
\newcommand{\ra}{\mathsf{RA}}
\newcommand{\cp}{\mathsf{CP}}
\newcommand{\rpk}{\mathsf{rpk}}
\newcommand{\rsk}{\mathsf{rsk}}
\newcommand{\dsk}{\mathsf{dsk}}
\newcommand{\apk}{\mathsf{apk}}
\newcommand{\ask}{\mathsf{ask}}
\newcommand{\rai}{\mathsf{rai}}
\newcommand{\cci}{\mathsf{cci}}
\newcommand{\wpid}{\mathsf{w_{pid}}}
\newcommand{\wctx}{\mathsf{w_{ctx}}}
\newcommand{\ri}{\mathsf{ri}}
\newcommand{\s}{\mathsf{s}}
\newcommand{\acc}{\mathsf{acc}}
\newcommand{\attrs}{\mathsf{attrs}}
\newcommand{\precred}{\mathsf{precred}}
\newcommand{\escrow}{\mathsf{escrow}}
\newcommand{\audit}{\mathsf{AUD}}
\newcommand{\rely}{\mathsf{REL}}

% Lists
\newcommand{\ul}{\mathsf{UL}}
\newcommand{\ctxl}{\mathsf{CTXL}}

% RL


\newcommand{\ctxid}{\mathsf{ctx}_{id}}
\newcommand{\cpid}{\mathsf{CP}_{id}}


% COM
\newcommand{\cmcom}{\mathsf{CM.Com}}
\newcommand{\cmopen}{\mathsf{CM.Open}}


% IBE
\newcommand{\ibekg}{\mathsf{IBE.KeyGen}}
\newcommand{\ibeextract}{\mathsf{IBE.Extract}}
\newcommand{\ibeenc}{\mathsf{IBE.Enc}}
\newcommand{\ibedec}{\mathsf{IBE.Dec}}

% TPKE.Enc
\newcommand{\tpkeenc}{\mathsf{TPKE.Enc}}
\newcommand{\tpkdec}{\mathsf{TPKE.Dec}}

% PS
\newcommand{\psrerand}{\mathsf{PS.Rerand}}
\newcommand{\psverify}{\mathsf{PS.Verify}}

% PRF
\newcommand{\vrfgen}{\mathsf{PRF.Gen}}
\newcommand{\vrfprove}{\mathsf{PRF.Prove}}
\newcommand{\vrfverify}{\mathsf{PRF.Verify}}

\newpage
\section{The System}
\textbf{Issuance}
\begin{itemize}
    \item To obtain a credential, a user generates an issuance token defining the attribute values of the credential to be issued using ITGen. Once the issuer has received an issuance token (and verified it using ITVf), the user and the issuer run 〈U.Issue, I.Issue〉, at the end of which the user obtains a credential.
    % from PABC systems
    \item Using Present, users can create non-interactive presentation tokens from their credentials in which they can reveal any subset of attributes from any subset of their credentials, or prove that certain attribute values are equal without revealing them....
    \item Issuance can be combined with the presentation of existing credentials to obtain a partially blind form of issuance, where some of the attribute values are known to the issuer, others are hidden but proved to be equal to attributes in credentials the user already owns, and even others are chosen by the user and unknown to the issuer. Hence, issuance tokens can be seen as an extension of presentation tokens.
\end{itemize}



\section{Protocol Syntax}
After public parameter creation, we assume each algorithm receives public parameters as input $\ppar$
\subsection{Setup and Key Generation}
\begin{itemize}
    \item $\mathsf{Setup}(\secparam) \torand \ppar:$ inputs the security parameter $\lambda$ in unary, outputs system parameters $\ppar$

    \item $\mathsf{UserKeyGen}() \torand (usk1, upk1):$ run by the user, outputs keypair

    \item $\mathsf{IssuerKeyGen}() \torand (isk_i, ipk_i):$ run by each $CA$, outputs $CA$ key pair (or threshold based) $isk_i, ipk_i$
\end{itemize}

\subsection{Level-1 Credential Operations}
\begin{itemize}
    \item $\mathsf{RequestLvl1}(attrs_1, usk_1, upk_1) \torand \pi_{1}$ run by a user, outputs $\pi_{1}$ the proof of identity validity. $\pi_1$ proves 
    \begin{enumerate}
        \item user knows $usk_1$ corresponding to $upk_1$
        \item identity attributes are valid
        \item proof of correct identity process followed, can be non-cryptographic or for example biometric based
    \end{enumerate}

    \item $\mathsf{IssueLvl1}(sk_{ca_1}, usk_1, upk_1, \pi_{1}, attrs_1) \to cred_1, \sigma_1:$ run by the $CA_1$ with inputs from $\mathsf{RequestLvl1}$. Outputs $(cred_1, \sigma_1)$ to user
\end{itemize}


\subsection{Level-2 Credential Operations}
\begin{itemize}
    \item $\mathsf{RequestLvl2}(cred_1, cred2Type, attrs_2) \to pk_2, \pi_{2}:$ Run by a user, inputs Level-1 credential $cred_1$, desired L2 credential type $cred2Type$, L2 credential attributes $attrs_2$. Computes $(sk_2, pk_2) \gets \mathsf{DeriveKey}(sk_1, cred2Type)$. Outputs derived public key $pk_2$ and $\pi_2$ proves:
    \begin{enumerate}
        \item user has valid $cred_1$
        \item $pk_2$ was correctly derived from $sk_1$ using $cred2Type$
        \item user knows $sk_2$ corresponding to $pk_2$
    \end{enumerate}

    \item $\mathsf{IssueLvl2}(cred_1, pk_1, pk_{ca_1}, \pi_2, sk_{ca_2}, pk_2, attrs_2) \to (cred_2, \sigma_2): $ run by $CA_2$, verifies $\pi_2$, checks $pk_2$ hasn't been issued before (Sybil Check). Outputs Level-2 credential $cred_2$ and signature $\sigma_2$
\end{itemize}



\subsection{Verification Operations}
\begin{itemize}
     \item $\mathsf{ProveLvl1}(cred1, \phi) \to \pi_3, aux:$ run by a user, inputs level-1 credential $cred_1$ and statement to prove $\phi$. Outputs a proof $\pi_3$ proves:
     \begin{enumerate}
         \item User possess a valid $cred_1$
         \item public and private attributes satisfy $\phi$
     \end{enumerate}
     and auxiliary information $aux$ such as selectively disclosed attributes
     
     \item $\mathsf{ProveLvl2}(cred_1, cred_2, \phi) \to (\pi_4, aux)$ run by a user, takes $cred_1, cred_2$ as input and $\phi$ the statement to prove. Outputs $\pi_4$ which proves:
     \begin{enumerate}
         \item user possesses valid $cred_2$
         \item $cred_2$ is linked to a valid $cred_1$
         \item $pk_2$ was correctly derived from $sk_1$
         \item selected attributes satisfy $\phi$
     \end{enumerate}
     and auxiliary information $aux$ such as selectively disclosed attributes

     \item $\mathsf{VerifyLvl1}(\pi_3, \phi, aux) \to \bit$
     \item $\mathsf{VerifyLvl2}(\pi_4, \phi, aux) \to \bit$
     run by a verifier, inputs proof, statement, auxiliary information. Outputs accept/reject
\end{itemize}


\subsection{Key Derivation and Revocation}
\begin{itemize}
    \item $\mathsf{DeriveKey}(sk_1, T) \to (sk_2, pk_2): $ run by a user, takes as input Level-1 secret key $sk_1$, credential 2 type $T$, computes $sk_2 = PRF_{sk_1}(T), pk_2 = g^{sk_2}$, outputs derived keypair $sk_2, pk_2$
    
    \item $\mathsf{Revoke}(sk_1, T) \to revocationInfo: $ run by a revocation authority, takes as input the level-1 secret key $sk_1$ and credential type $T$. Outputs information to add to the revocation list including $pk_2$
\end{itemize}

\subsection{Protocol Properties}
\begin{enumerate}
    \item \textbf{Proof Hierarchy}
    \begin{itemize}
        \item $\pi_1$: Identity Proof, one-time during L1 issuance
        \item $\pi_2$: Credential Linkage proof, during L2 issuance)
        \item $\pi_3$: L1 validity proof, during L1 verification
        \item $\pi_4$: Combined L1 + L2 proof, L2 verification
    \end{itemize}

    \item \textbf{Privacy Properties}
    \begin{itemize}
        \item Proofs $\pi_3, \pi_4$ support selective disclosure
        \item L2 credentials are unlinkable to L1 credentials for verifiers
        \item Different L2 credentials of the same user are unlinkable 
    \end{itemize}

    \item \textbf{Security Properties}
    \begin{itemize}
        \item Deterministic key derivation ensures Sybil Resistance
        \item Revocation of L1 credential enables L2 credential revocation
        \item Zero Knowledge Proofs ensure minimal information disclosure
    \end{itemize}
\end{enumerate}


\section{System Model and Requirements}

\subsection{Entities}

\subsubsection{Level-1 Certificate Authority (L1-CA)}
Top Hierarchy Credential issued by a high-security root issuer e.g. government / passport authority who operates a secure threshold infrastructure. They're responsible for issuing L1 Credentials and maintaining revocation status.

\subsubsection{Level-2 Certificate Authority (L2-CA)}
The L2 credentials are issued by any credential provider, such as the DMV or universities. They're responsible for verifying L1-Creds, Issuing domain-specific credentials, preventing Sybil attacks through nullifier checks, and maintaining their own revocation lists.

\subsubsection{Users}
Hold a wallet of credentials including L1-Creds such as a digital passport, users request L2-Creds, generate proofs for verification. They're responsible for protecting their secret keys, generating derived keys, and creating zero knowledge proofs.

\subsubsection{Verifiers}
Can be a separate entity, they check credential validity, requesting specific proofs from users. No special trust assumptions, may be offline during verification.

\subsection{Trust Model}

\subsubsection{Trust Assumptions}
\begin{itemize}
    \item \textbf{L1-CA} is trusted to issue L1-Cred through a potentially non-cryptographic mean. Furthermore, they're trusted to run a secure key generation and have accurate revocation status

    \item \textbf{L2-CA} are trusted to properly issue credentials for their domain, maintain records of public keys/nullifiers for revocation, follow protocol specifications

    \item \textbf{Users} are not trusted: they may attempt to create multiple identities, they may attempt to forge credentials, they may attempt to link credentials maliciously

    \item \textbf{Verifiers} are not trusted, they may attempt to link multiple credentials to a user identity to learn more information than specified in the protocol about a user or their credential
\end{itemize}

\subsubsection{Threat Model}
The adversary 
\begin{itemize}
    \item may control less than t of n L1-CA nodes but cannot compromise more than $t$ nodes
    \item may control multiple L2-CA's
    \item May corrupt users
    \item May observe all public communication
    \item Cannot break cryptographic primitives
\end{itemize}

\section{Security Requirements}

\subsection{Privacy Properties}
\begin{enumerate}
    \item Credential Unlinkability
    \begin{itemize}
        \item Different L2 Credentials of the same user are unlinkable
        \item L2 Credentials can't be linked to L1 Credentials
        \item Different uses of the same credential are unlinkable
    \end{itemize}

    \item Selective Disclosure
    \begin{itemize}
        \item Users can choose which attributes to reveal
        \item minimum disclosure for credential validity
    \end{itemize}

    \item Zero-Knowledge Proofs
    \begin{itemize}
        \item Leak no information beyond credential validity and auxiliary information 
    \end{itemize}
\end{enumerate}

\subsection{Security Properties}
\begin{enumerate}
    \item \textbf{Unforgeability:} 
    \begin{itemize}
        \item Cannot create valid credentials without CA approval. 
        \item Cannot modify existing credentials
    \end{itemize}

    \item \textbf{Sybil Resistance:}
    \begin{itemize}
        \item One L1 credential maps to one L2 credential per type
        \item deterministic but private key derivation
    \end{itemize}

    \item \textbf{Non-Transferrability:}
    \begin{itemize}
        \item Credentials can't be shared between users
        \item Requires knowledge of secret keys
    \end{itemize}

    \item \textbf{Revocation: }
    \begin{itemize}
        \item L1 credential revocation cascades to L2]
        \item L2 credential revocation doesn't impact L1 or other L2
        \item Efficient revocation checking
    \end{itemize}
\end{enumerate}

\section{Performance Requirements}

\subsection{Efficiency Goals}
\begin{enumerate}
    \item Minimial L1-CA interaction
    \begin{itemize}
        \item L2 credential issuance without L1-CA
        \item Offline verification possible
    \end{itemize}

    \item Computational Efficiency
    \begin{itemize}
        \item Efficient proof generation and verification
        \item Efficient credential issuance
    \end{itemize}

    \item Storage Efficiency
    \begin{itemize}
        \item Compact Credential
        \item Compact Key Size
        \item Efficient revocation list (not in the size of the list)
    \end{itemize}
\end{enumerate}

\subsection{Scalability}
Support millions of users, thousands of L2-CA's, many L2-CA credential types. Network with minimal bandwidth usage


\subsection{Correctness}
A hierarchical credential system is correct if for all security parameters $\lambda$:
\subsubsection{Key Derivation Correctness}
For any Level-1 secret key $sk_1$ and credential type $T$, 
\[
    \Pr[(usk2_T, upk2_T) \gets \mathsf{DeriveKey(usk1, T)}] = 1
\]
Informally, this states that the $\mathsf{DeriveKey}$ function is deterministic.


\subsubsection{Level-1 Credential Correctness}
For all Level-1 attributes $attrs_1$, messages $m$ and $D_1 \subseteq attrs_1$ are disclosed attributes

\[
        \Pr
            \left [
                \mathsf{VerifyLvl1(\pi_1, \phi, D_1) = 1} \middle|
                \begin{array}{l}
                    \mathsf{pp} \gets \mathsf{Setup}(1^{\lambda}), \\
                    \mathsf{isk_1, ipk_1} \gets \mathsf{IssuerKeyGen(pp)}, \\
                    \mathsf{(usk_1, upk_1)} \gets \mathsf{UserKeyGen(pp)}, \\
                    \sigma_1 \gets \mathsf{Sign_1}(upk1, attrs_1, isk_1), \\
                    cred_1 \gets (\sigma_1, attrs_1, upk_1, usk_1), \\
                    \pi_1 \gets \mathsf{ProveLvl1}(cred_1, m, D_1)
                \end{array}
                \right ]
                 = 1
\]



\subsubsection{Level-2 Credential Correctness}
For all Level-2 attributes $attrs_2$ and arbitrary message $m$ e.g. a transaction or challenge, given a valid Level-1 credential secret key $usk_1$

\[
        \Pr
            \left [
                \mathsf{VerifyLvl2(\pi_1, m, D_1, D_2) = 1} \middle|
                \begin{array}{l}
                    (usk_2, upk_2) \gets \mathsf{DeriveKey}(usk_1, T), \\
                    \sigma_2 \gets \mathsf{Sign_2}(isk_2, upk_2, attrs_2), \\
                    cred_2 \gets (\sigma_2, attrs_2, upk_2, usk_2) \\
                    \pi_2 \gets \mathsf{ProveLvl2}(cred_2, cred_1, m, D_1, D_2)
                \end{array}
                \right ]
                 = 1
\]
Where $D_1 \subseteq attrs_1$ are disclosed attributes from L1 Credential, $D_2 \subseteq attrs_2$ are disclosed attributes from L2 Credential, $m$ is an arbitrary message e.g. nonce. $\mathsf{ProveLvl2}$ creates a zero knowledge proof that $cred_2$ is valid under $isk_2$, $\Prover$ knows a valid $cred_1$, $upk_2$ was correctly derived from $usk_1$ and $m$ has been signed.

\subsection{Oracles  These are all incorrect!!!}
The adversary $\Adv$ has access to the following oracles:




\begin{itemize}
    \item $\mathcal{O}^{\texttt{UserKeyGen}}(\ppar)$: Oracle for generating user keypairs. Generates a fresh keypair $(upk_1, usk_1)$. Maintains an internal list of keypairs $\texttt{UserKeys}$. Returns the public key $upk$ only.
    
    \item $\mathcal{O}^{\texttt{RequestL1}}(upk_1, attrs_1)$: Oracle for requesting L1 credentials. Takes the user's L1 public key $upk_1$ and attribute list $attrs_1$. Checks $upk_1 \in \texttt{UserKeys}$. Generates $\pi_1$ proving identity attributes are valid, proof of correct identity process followed, $upk_1$ is valid. Returns $\pi_1$. Maintains an internal list $\texttt{L1CredReqs}$ of credential requests

    \item $\mathcal{O}^{\texttt{IssueL1}}(isk_1, upk_1, \pi_1, attrs_1)$: Oracle for L1 Credential Issuance. Verifies $\pi_1$ and the request exists in $\texttt{L1CredReqs}$. If valid, generates credential and signature $(cred_1, \sigma_1)$, adds to internal list $\texttt{L1Creds}$, returns $cred_1, \sigma_1$

    \item $\mathcal{O}^{\texttt{RequestL2}}(cred_1, T, attrs)$: Oracle for requesting L2 credentials. Takes as input L1 credential $cred_1$, new credential type $T$, and $attrs$. Returns $upk_2, \pi_2$. Maintains an internal list $\texttt{L2CredReqs}$

    \item $\mathcal{O}^{\texttt{IssueL2}}(upk_2, \pi_2, attrs)$: Oracle for L2 Credential Issuance. Verifies $\pi_2$ and checks for Sybil attack. If valid, generates $\cred_1$, adds to $\texttt{L2Creds}$, returns $(\cred_2, \sigma_2)$

    \item $\mathcal{O}^{\texttt{ProveL1}}(cred_1, \phi)$: Oracle for generating L1 credential proofs. Takes credential $cred_1$ and statement $\phi$. Returns $\pi_3, aux$ from $\texttt{ProveLvl1}$. Maintains list of generated proofs $\texttt{Proofs}$
    
    \item $\mathcal{O}^{\texttt{ProveL2}}(cred_1, cred_2, \phi)$: Oracle for generating L2 credential proofs. Takes credentials $cred_1, cred_2$ and statement $\phi$. Returns $(\pi_4, aux)$ from $\texttt{ProveLvl2}$. Adds to $\texttt{Proofs}$.

    \item $\mathcal{O}^{\texttt{Corrupt}}(id)$: Corruption Oracle. Returns all secrets for entity id $id$, adds $id$ to $\texttt{Corrupt}$ list.

    \item $\mathcal{O}^{\texttt{Revoke}}(usk_1, T)$: Revocation Oracle. Revokes credentials and updates revocation information. Adds $upk_1$ or $upk_2i$ to $\texttt{Revocations}$
    
\end{itemize}
