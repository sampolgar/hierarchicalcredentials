\section{Abstract}
Main Research Question: 

\textit{How can credential systems be designed to maintain accountability and sybil resistance with privacy and unlinkability. }

\noindent Sub Research Questions

\textit{How can we design a privacy-preserving credential system that enables hidden linking of government and private credentials while maintaining provable provenance and revocability?}

\textit{How can we efficiently combine credentials for verification while retaining their security properties}

\newpage
\section{Intro}
In this section, we discuss the sub-problem:
\textit{How can we design a privacy-preserving credential system that enables hidden linking of government and private credentials while maintaining provable provenance and revocability?}



% When answering, discuss how they motivate, in which setting and why it’s important, and what they’re missing / outstanding work.
% – How used / important is "certified sampling" ?
% – How is it done (if it exists) ?

% Motivation
% https://eprint.iacr.org/2024/1124.pdf#page=14.48
% https://pages.nist.gov/800-63-4/sp800-63c.html

\subsection{Motivation}


\paragraph{Internet Identity Workshop}

The Internet Identity Workshop discussed a problem space summarised by the following problems:
1. issuing credentials that are both government and privately issued
2. retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
3. combining traditional digital identity with decentralized identity

A user has an Identity linked to multiple credentials, such as a driver's license and university card. Users want to authenticate with various Relying Parties (Verifiers) without being linked between multiple uses of the same service (e.g. a user verifying multiple credentials with 1 service such as a bank requiring proof of multiple credentials linked to an identity), and between uses of different services (e.g. a user presenting their drivers license for age verification on multiple services).

Current decentralized identity systems either don't provide this functionality or provide it at the expense of either accountability or privacy. CanDID stores a map between users multi-layered credentials providing a solution to the problem at the expense of the user's privacy. Other credential systems and pseudonym systems prove equality of hidden attributes in a credential such as name or id, which can more-easily be forged and does not support the hierarchical structure leveraging a highly secure and accountable government identity with not-so secure private credentials.

\paragraph{Identity Provider Features (Pairwise Pseudonyms, Unobservability}
Identity Providers (IdP's)/SSO systems enable a user with a single identity (uid) to login to multiple services called Relying Parties (RP). User's wanting to authenticate with an RP are redirected to the IdP to login, the IdP then sends a cryptographic token to the RP attesting to the user's permission to login, sharing user identifier uid and optionally user attributes.
\textbf{Unlinkability:} To prevent different RP's from tracking the user's uid (a privacy problem), pairwise pseudonyms were proposed, and recommended by NIST to improve user privacy, and currently used by Apple's SSO service. Pairwise pseudonyms create a new problem - the record of user id uid and pairwise id ppid needs to be stored on the IdP on a central service and accessed for each login request and therefore every authentication request can be tracked by the IdP. 

OpenID Connect (OIDC) supports pairwise pseudonyms by setting $ppid = H(k, uid, rid)$ where H is a hash function, $k$ is a random key and $rid$ is the relying party. During login, the IdP generates ppid and stores it, then sends $ppid$ instead of $uid$ to the RP. User's cannot generate more than 1 ppid and thus \textbf{pseudonym Sybil Resistance} is upheld. 

Observability is defined by the notion that each authentication request from a relying party RP to the IdP enables IdP to observe the user's identity usage. Furthermore, to prevent reply attacks, the IdP includes RP specific information in the authentication token to prevent multiple uses or uses for the wrong RP.

OPPID \cite{kroschewski_oppid_2024} supports unlinkability (across relying parties), sybil resistance (for each context) and unobservability (which prevents the IdP from learning each RP the user interacts while retaining their requirement to bind their login token to an RP). OPPID enhances privacy in pseudonym login tokens by hiding which RP is being used while retaining existing security requirements.


\subsection{Hierarchical Credentials}




The user's Level-1 credential forms the root of trust.
We want a way to privately prove Level-1 credentials are valid when using Level-2 credentials, when the attributes in each credential are different. We want to allow verification of Level-1 credential status without revealing which Level-1 credential it is, maintain revocation across levels.
\begin{itemize}
    \item \textbf{Level-1 (High Security):} Government issues passport credentials using secure threshold infrastructure (foundational identity credentials for users)
    \item \textbf{Level-2 (Lower Security):} Organisations like DMV, Universities, Running their own credential infrastructure. Want to privately link users to Level-1 Credential for accountability and higher security (borrowing security from Level-1). If a Level-1 credential is revoked, level-2 can borrow it's revocation
\end{itemize}

The problem I'm addressing
\begin{enumerate}
    \item creating a hierarchical credential system where high-security credentials (Level-1, like passports) can be linked to lower security credentials (Level-2, like driver's license)
    \item Solving the privacy vs accountability trade-off that exists in current systems like CanDID
\end{enumerate}

Novel Contribution
\begin{enumerate}
    \item Privacy-Preserving link between credential levels using deterministic key derivation
    \item Efficient and Private system design which doesn't require Level-1 CA interaction for Level-2 Credentials. Maintains privacy for Level-1 Credentials, enables accountability and Sybil Resistance
    \item Zero-Knowledge Proof System allowing credential verification and proof of correct link between credentials, selective disclosure, revocation checking across levels
\end{enumerate}


\subsection{Related Works}
\begin{itemize}
    \item CanDID Decentralized Identity records the state i.e. (level1-pk, level2-pk) on the level1 ca. This is not private and requires interacting with level-1 for each credential issued which isn't good because it will overwhelm level-1 ca.

    \item OpenID, Apple SSO, IdP

    \item Commitment Equality

    \item Link-G16

    \item Anonymous Payment Systems are analogous to Private Identity Systems
    
\end{itemize}



Draft Proposed Flow of information
When user gets Level-1 credential (passport):
Gets credential containing their attributes
Also receives a deterministic secret key derived from their Level-1 credential
For Level-2 credential issuance (e.g., driver's license):
User proves possession of valid Level-1 credential to Level-2 issuer
User creates a zero-knowledge proof that their Level-2 public key is derived from their Level-1 secret key
This creates cryptographic link without revealing the actual Level-1 credential


During verification of Level-2 credential:
User proves their credential is valid
If needed, can prove Level-1 credential status without revealing which specific Level-1 credential
Could use techniques like set membership proofs to prove Level-1 credential is not in revocation set

The key would be finding the right cryptographic primitives to:

Create deterministic but unlinkable derivation between Level-1 and Level-2 keys
Allow proving relationship between keys without revealing them
Enable efficient revocation checking


Draft system idea for privately linking credentials
generate randomness: $r = PRF_sk1(level-2-credname)$
generate level2 keypair $sk2 = r, pk2 = g^r $(for a discrete log based keypair example)
Then when verifying level2 credentials, we can tie the accountability back to level1 credentials privately if needed
Private linkage (can't tell which level-1 credential without sk1)
Accountability (can verify level-1 credential status if needed)
No interaction with level-1 CA during level-2 issuance
Deterministic derivation (same user always gets same level-2 key for a given credential name)
Yes exactly! The deterministic derivation of pk2 = $g^PRF_sk1(level-2-credname)$ provides Sybil resistance because:

For a given level-1 credential (with unique sk1) and level-2 credential type (e.g., "drivers-license"), there can only be one possible pk2
The level-2 CA can check if pk2 was already used before issuing a new credential
Users can't create multiple different pk2s for the same level-2 credential type since it's deterministically derived from their level-1 sk1

From the CA's perspective:

They maintain a list of issued pk2s
When a new user requests a level-2 credential, they check if that pk2 exists
If it exists, this user already has this type of credential
If not, it's their first time requesting this credential type

The beauty is:

This Sybil check is done without revealing which level-1 credential the user has
The level-2 CA only needs to track pk2s, not any level-1 credential information
Different level-2 credentials for the same user will have different, unlinkable pk2s due to different credential names in the PRF

\newpage
\section{Registration}


\newpage
\section{Verification}
2 methods to privately prove two or more credentials are linked together are proving equality of attributes within commitments and proving that a Level2 credential contains a derivation of the Level1 credential, linking the two together in a hierarchy. 
We asymptotically compare the 2 approaches modelled using Pedersen Commitments and Sigma Protocols as used in many popular Anonymous Credential schemes.

\begin{itemize}
    \item Equality proof method using $Com_1([pid],r_1)$ and $Com_2([pid,ctx],r_2)$
    \item Derivation proof method using $Com_1([pid],r_1)$ and $Com_2([prf(pid,ctx),ctx],r_2)$
\end{itemize}

While proving equality between commitments does not add additional overhead, proving derivation requires additional Prover and Verifier work scaling linearly with respect to the number of credentials being verified
\begin{itemize}
    \item \textbf{Prover:} 3 exponentiation in $\G_1$, 5 add/mul in $\F_p$, 1 inverse operation in $\F_p^{inv}$ and 1 additional commitment $Com$
    \item \textbf{Verifier:} 2 exponentiations in $\G_1$, 3 add/mul in $\F_p$
\end{itemize}

\subsubsection{Equality of committed string}
This method uses sigma protocol with the same challenge $c$ to prove the response $z_{pid}$ can be used to prove knowledge of the opening of both commitments and thus the string must be the same.
\[
ZKP
    \left\{ 
    (pid, r_1, r_2): Com_1 = g_1^{pid} h^{r_1} \wedge Com_2 = g_1^{pid} h^{r_2}
    \right\}
\]

\pcb{
\textbf{User} \< \< \textbf{Verifier}  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
pid, r1, r2 \<\< Com_1, Com_2 \\
a, \rho_1, \rho_2 \sample \mathbb{Z}_q^3 \<\< \\
T_1 := g_1^a h^{\rho_1} \<\< \\
T_2 := g_1^a h^{\rho_2} \< \sendmessageright*{T_1, T_2} \< \\
\< \sendmessageleft*{c} \< c \sample \mathbb{Z}_q \\
z_{pid} = a + c \cdot pid \<\< \\
z_{r_1} = \rho_1 + c \cdot r_1 \<\< \\
z_{r_2} = \rho_2 + c \cdot r_2 \<\< \\
\< \sendmessageright*{z_{pid}, z_{r1}, z_{r2}} \< \\
\<\< g_1^{z_{pid}} h^{z_{r_1}} \stackrel{?}{=} Com_1^c \cdot T_1 \\
\<\< g_1^{z_{pid}} h^{z_{r_2}} \stackrel{?}{=} Com_2^c \cdot T_2 \\
}

\begin{itemize}
    \item Proving knowledge of openings $(pid, r1)$ and $(pid, r2)$ for commitments $Com1 = g_1^{pid}h^{r1}$ and $Com2 = g_1^{pid}h^{r2}$
    \item Proves equality of $pid$ across both commitments
\end{itemize}



\newpage
\section{Methods}


% Let $a : \N \mapsto \N \bigcup \{*\}$ and $b : \N \mapsto \N$ be any functions for which $a(\lambda)$ and $b(\lambda)$ are computable in $poly(\lambda)$ time (expect when $a$ takes value $*$).
% % \begin{definition}
% %     A function family $F_{(\cdot)}(\cdot) : \bit^{a(\lambda)} \mapsto \bit^{b(\lambda)}$ is a family of $VRFs$ if there exists a PPT algorithm $Gen$ and deterministic algorithms $Prove$ and $Ver$ such that $Gen(\secparam)$ outputs a pair of keys $(sk, pk)$, $Prove_{sk}(x)$ computes $(y, \pi)$ where $\pi$ is the proof of correctness, and $Ver_{pk}(x,y,\pi)$ verifies that $y = e(g,g)^{1/x+sk}$ using the proof $\pi = g^{1/x+sk}$
% % \end{definition}

\subsection{Pseudo Random Function}
We use the properties of a pseudo-random function to derive the relationship between a master and context credential. The pseudorandomness property ensures the output $y$ is computationally indistinguishable from random and thus hides the relationship between the user's secret key $sk$ and an input $x$ which could be the context of the new credential we want to privately link to.
\[
    PRF_{sk}(x) \to y
\]

\begin{definition}[Pseudo Random Function]
    A PRF is a couple of algorithms $(PRF.Gen, f)$ with key space $\setK$, input space $\setX$ and output space $\setY$ such that 
    \begin{itemize}
        \item $Gen(\secparam) \to (sk): s \sample S$, sets $sk = s$
        \item $f:$ $\mathcal{K} \times \mathcal{X} \to \mathcal{Y}$ is a keyed function family
    \end{itemize}
\end{definition}

The main security property of a $PRF$ is pseudorandomness, which informally states the output should appear random and not be able to be guessed. Formally, defined as

\begin{definition}[Pseudorandomness]
    A couple of PPT algorithms $(PRF.Gen, f)$ is a \textit{Pseudo Random Function} if, for any $\PPT$ adversary $\adv$ there exists a negligible function $\epsilon$ such that 
    \[
    \advantage{}{}[(\adv)] := 
        \left|
    \Pr     \left[ 
                \mathsf{Exp}^{\mathsf{prf}}(\adv) = 1
            \right] - \frac{1}{2}
        \right| \leq \epsilon(\lambda)
    \]
\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{prf}}(\adv)$}{%
        b \sample \bit \\
        \text{Sample } k \sample PRF.Gen(1^{\lambda}) \\
        \text{Sample } f^* \sample \{g : g : \mathcal{X} \to \mathcal{Y}\} \\
        \text{Run } b' \gets \adv^{\oracle_{\mathsf{prf}}}(1^{\lambda}) \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{prf}(x)}$}{%
        \pcif b = 1 \\
        \t \pcreturn f_k(x) \\
        \pcelse \\
        \t \pcreturn f^*(x)
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}


\subsection{Verifiable Random Function}

\subsubsection{Syntax}
\begin{itemize}
    \item $Gen(\secparam) \to (sk, pk):$ samples $s \sample \Zp^*$, sets $sk = s$ and $pk \gets g^s$, returns $(sk, pk)$
    \item $Prove_{sk}(x) \to (y, \pi):$ $y \gets e(g,g)^{1/(x+sk)}$, $\pi \gets g^{1/(x+sk)}$ where $y$ is the $PRF$ output and $\pi$ is the proof of correctness
    \item $Verify_{pk}(x, y, \pi) \to \bit$ to verify $y$ was computed correctly, verify $e(g^x \cdot pk, \pi) = e(g,g)$ and $y = e(g, \pi)$, output 1 for success, 0 for fail
\end{itemize}

\begin{definition}[Verifiable Random Function]

    A PRF is a triplet of $\PPT$ algorithms $(VRF.Gen, VRF.Eval, VRF.Vfy)$ satisfying:
    \begin{enumerate}
        \item Correctness: For any $(pk, sk)$ in the image of $VRF.Gen(\secparam)$ and any $x \in \setX$
        \[
        \begin{aligned}
            (y, \pi) &\gets VRF.Eval_{sk}(x) \\
            1 &\gets VRF.Vfy_{pk}(x, y, \pi)
        \end{aligned}
        \]


    \item Unique Provability: For any $pk$ (not necessarily in the range of $VRF.Gen$, any input $x \in \setX$, pair of outputs $y_0, y_1 \in \setY$ and pair of proofs $\pi_0, \pi_1$ the following holds
    \[
        \begin{aligned}
            1 &\gets VRF.Vfy_{pk}(x,y_0,\pi_0) \\
            1 &\gets VRF.Vfy_{pk}(x,y_1,\pi_1) \\
            y_0 &= y_1
        \end{aligned}
    \]

    \item Pseudorandomness: For any $\PPT$ adversary $\adv$ running the VRF Experiment, there exists a negligible function $\epsilon$ such that 
    \[
         \advantage{}{}[(\adv)] := 
            \left|
        \Pr     \left[ 
                    \mathsf{Exp}^{\mathsf{rnd}}(\adv) \to 1
                \right] - \frac{1}{2}
            \right| \leq \epsilon(\lambda)
    \]
    
    \end{enumerate}

\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{eval}}(\adv)$}{%
        \text{Sample } b \sample \bit \\
        pk, sk \sample VRF.Gen(1^{\lambda}) \\
        \text{set } x^* = \bot \\
        x^* \gets \adv^{\oracle_{\mathsf{eval}}}(pk) \\
        \pcif x^* \text{was previously queried:} \\
        \t \pcreturn 0 \\
        y_0 \sample \setY \\
        (y_1, \pi) \gets VRF.Eval(pk, x^*) \\
        \adv^{\oracle_{\mathsf{eval}}}(sk, y_b) \to b' \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{eval}(x)}$}{%
        \pcif x \neq x^* \\
        \t (y, \pi) \gets VRF.Eval_{sk}(x) \\
        \t \pcreturn (y, \pi) \\
        \pcelse: \pcreturn \bot \\
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}

\paragraph{Description}










\newpage
\section{Sam and Tian 15/11}

\subsection{ZKP Sigma Protocol for proving PRF output in G1}
We have $g^{\frac{1}{m}}$ and $g^m$. We want to prove their relationship is reciprocal. We will use this later when proving the output of the Dodis Yampolskiy VRF $g^{\frac{1}{sk + x}}$
Let $m_1 = m$, and $m_2 = \frac{1}{m}$. Therefore, we can prove that $m_1 \cdot m_2 = 1$ 
\[ 
    \begin{aligned}
        C_1 &= g^{m_1}h^{r_1} \\
        C_2 &= g^{m_2}h^{r_2} \\
        C_3 &= C_1^{m_2}h^{r_3} \\ 
        C_4 &= h^{r_1m_2 + r_3} \\ 
    \end{aligned}
\]

We use $C_1, C_2$ in a zero-knowledge proof protocol to prove the relation with public elements $C_1, C_2, g, h$

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1
    \right\}
\]

\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g^{m_1}h^{r_1}, C_2 = g^{m_2}h^{r_2}$} \\
{\{\rho_i\}_{i=1}^4, \{\beta_i\}_{i=1}^2}  \sample \mathbb{Z}_q^6 \<\< \\
T_1 \gets g^{\beta_1}h^{\rho_1} \<\< \\
T_2 \gets g^{\beta_2}h^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
C_3 \gets C_1^{m_2}h^{r_3} \<\< \\
T_3 \gets C_1^{\beta_2}h^{\rho_3} \<\< \\
r_4 \gets r_1m_2 + r_3 \<\<  \\
C_4 \gets h^{r4} \<\< \\
T_4 \gets h^{\rho_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
z_{m1} = \beta_1 + e \cdot m_1 \<\< \\
z_{r1} = \rho_1 + e \cdot r_1 \<\< \\
z_{m2} = \beta_2 + e \cdot m_2 \<\< \\
z_{r2} = \rho_2 + e \cdot r_2 \<\< \\
z_{r3} = \rho_3 + e \cdot r_3 \<\< \\
z_{r4} = \rho_4 + e \cdot r_4 \<\< \\
\< \sendmessageright*{\{z_{mi}\}_{i=1}^2, \{z_{ri}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g^{z_{m1}} h^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g^{z_{m2}} h^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  C_1^{z_{m2}} h^{z_{r3}}\\
\<\< C_4^e \cdot T_4 \stackrel{?}{=}  h^{z_{r4}}\\
\<\< C_3/C_4 = g \\
}

\subsection{Correctness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$ 
\begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag 
\end{align}

Proof of knowledge of exponents $m2, r2$ by opening $C_2$ 
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} g^{z_{m2}} h^{z_{r2}} && \label{eq:ver1} \\
    (g^{m2}h^{r_2})^e \cdot g^{\beta_2}h^{\rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag \\
    g^{e \cdot m2 + \beta_2}h^{e \cdot r_2 + \rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag 
\end{align}


Equality of $m2 \in \{C_2, C_3\}$ proven by equality of responses $g^{z_{m2}}$ used in \eqref{eq:ver1} and \eqref{eq:ver2}
\begin{align}
    C_3^e \cdot T_3 &\stackrel{?}{=} C_1^{z_{m2}} h^{z_{r3}} \notag \\
    (C_1^{m2}h^{r_3})^e \cdot C_1^{\beta_2}h^{\rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \label{eq:ver2} \\
    C_1^{m2 \cdot e + \beta_2}h^{e \cdot r_3 + \rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \notag
\end{align}

Proof of knowledge of exponent $r4$ by opening $C_4$ 
\begin{align}
    C_4^e \cdot T_4 &\stackrel{?}{=} h^{z_{r4}} \notag \\
    (h^{r_4})^e \cdot h^{\rho_4} &\stackrel{?}{=} h^{\rho_4 + e \cdot r_4} \notag \\
    h^{e \cdot r_4 + \rho_4} &= h^{\rho_4 + e \cdot r_4} \notag
\end{align}

Prove that $C_3/C_4 = g$ implies $g^{\frac{m1}{m2}} = 1$ which proves their inverse relation. Recall $C_1 = g^{m_1}h^{r_1}, r_4 = r_1m_2 + r_3$
\begin{align}
    \dfrac{C_3}{C_4} = \dfrac{C_1^{m2}h^{r_3}}{h^{r_4}} = \dfrac{(g^{m_1}h^{r_1})^{m2}h^{r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g^{m_1\cdot m2}h^{r_1\cdot m2 + r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g}{1} = g \notag \\
\end{align}

\subsection{Soundness}

\subsection{Zero Knowledge}


\subsection{ZKP Sigma Protocol for proving PRF output with pairing}

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1
    \right\}
\]