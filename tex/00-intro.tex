\section{Abstract}



\section{Intro}
% When answering, discuss how they motivate, in which setting and why it’s important, and what they’re missing / outstanding work.
% – How used / important is "certified sampling" ?
% – How is it done (if it exists) ?

% Motivation
% https://eprint.iacr.org/2024/1124.pdf#page=14.48
% https://pages.nist.gov/800-63-4/sp800-63c.html


Presenting multiple credentials for verification 

\subsection{Motivation}
Balancing accountability and privacy in credential systems.
A user has an Identity linked to multiple credentials, such as a driver's license and university card. Users want to authenticate with various Relying Parties (Verifiers) without being linked between multiple uses of the same service (e.g. a user verifying multiple credentials with 1 service such as a bank requiring proof of multiple credentials linked to an identity), and between uses of different services (e.g. a user presenting their drivers license for age verification on multiple services).

\subsection{Literature Review}
Identity Providers (IdP's)/SSO systems enable a user with a single identity (uid) to login to multiple services called Relying Parties (RP). User's wanting to authenticate with an RP are redirected to the IdP to login, the IdP then sends a cryptographic token to the RP attesting to the user's permission to login, sharing user identifier uid and optionally user attributes.
\textbf{Unlinkability:} To prevent different RP's from tracking the user's uid (a privacy problem), pairwise pseudonyms were proposed, and recommended by NIST to improve user privacy, and currently used by Apple's SSO service. Pairwise pseudonyms create a new problem - the record of user id uid and pairwise id ppid needs to be stored on the IdP on a central service and accessed for each login request and therefore every authentication request can be tracked by the IdP. 

OpenID Connect (OIDC) supports pairwise pseudonyms by setting $ppid = H(k, uid, rid)$ where H is a hash function, $k$ is a random key and $rid$ is the relying party. During login, the IdP generates ppid and stores it, then sends $ppid$ instead of $uid$ to the RP. User's cannot generate more than 1 ppid and thus \textbf{pseudonym Sybil Resistance} is upheld. 

\textbf{Observability: } is defined by the notion that each authentication request from a relying party RP to the IdP enables IdP to observe the user's identity usage. Furthermore, to prevent reply attacks, the IdP includes RP specific information in the authentication token to prevent multiple uses or uses for the wrong RP.


OPPID \cite{kroschewski_oppid_2024} supports unlinkability (across relying parties), sybil resistance (for each context) and unobservability (which prevents the IdP from learning each RP the user interacts while retaining their requirement to bind their login token to an RP). OPPID enhances privacy in pseudonym login tokens by hiding which RP is being used while retaining existing security requirements.

Breaking from the SSO IdP model, 











\subsection{Hierarchical Credentials}





Prove credentials have a link between them when there are no equal attributes.


This can be done by a user with multiple credentials and proving equality of attributes between credentials, the user needs to generate a non-membership proof with some private cryptographic object. 
We bypass this and maintain privacy and sybil resistance by ...
This method uses a PRF derived from msater credential.

Obtain and Issuing
Scenario 1: to obtain a context credential, 

Scenario 2 (improvement) we are better.


Linkable Show and Verify
Scenario 1: uses equality of commitment
Scenario 2: uses our method

Improvements
The concrete 













The user's Level-1 credential forms the root of trust.
We want a way to privately prove Level-1 credentials are valid when using Level-2 credentials, when the attributes in each credential are different. We want to allow verification of Level-1 credential status without revealing which Level-1 credential it is, maintain revocation across levels.
\begin{itemize}
    \item \textbf{Level-1 (High Security):} Government issues passport credentials using secure threshold infrastructure (foundational identity credentials for users)
    \item \textbf{Level-2 (Lower Security):} Organisations like DMV, Universities, Running their own credential infrastructure. Want to privately link users to Level-1 Credential for accountability and higher security (borrowing security from Level-1). If a Level-1 credential is revoked, level-2 can borrow it's revocation
\end{itemize}

The problem I'm addressing
\begin{enumerate}
    \item creating a hierarchical credential system where high-security credentials (Level-1, like passports) can be linked to lower security credentials (Level-2, like driver's license)
    \item Solving the privacy vs accountability trade-off that exists in current systems like CanDID
\end{enumerate}

Novel Contribution
\begin{enumerate}
    \item Privacy-Preserving link between credential levels using deterministic key derivation
    \item Efficient and Private system design which doesn't require Level-1 CA interaction for Level-2 Credentials. Maintains privacy for Level-1 Credentials, enables accountability and Sybil Resistance
    \item Zero-Knowledge Proof System allowing credential verification and proof of correct link between credentials, selective disclosure, revocation checking across levels
\end{enumerate}


\subsection{Related Works}
\begin{itemize}
    \item CanDID Decentralized Identity records the state i.e. (level1-pk, level2-pk) on the level1 ca. This is not private and requires interacting with level-1 for each credential issued which isn't good because it will overwhelm level-1 ca.

    \item Commitment Equality

    \item Link-G16
    
\end{itemize}



(Overview of this paper - this is just for my draft)
\textbf{Introduction}
\begin{itemize}
    \item Problem: Decentralized identity systems need both high-security root credentials and lower-security derived credentials
    \item Challenge: Creating private, accountable links between credential levels without overwhelming root CA
    \item Current approaches and their limitations (like the paper you mentioned that records state at level-1)
    \item Your contribution: A new scheme for privately linking credentials with Sybil resistance
\end{itemize}



\noindent \textbf{Background \& Related Work}
\begin{itemize}
    \item Foundations in digital credentials
    \item Anonymous credentials and zero-knowledge proofs
    \item Existing hierarchical/delegatable credential systems
    \item PRF-based key derivation schemes
\end{itemize}


\noindent \textbf{System Model \& Requirements}
\begin{itemize}
    \item Trust model (level-1 CA, level-2 CAs, users, verifiers)
    \item Security requirements:
    \item Privacy (unlinkability between levels)
    \item Accountability (level-1 credential status checking)
    \item Sybil resistance
    \item Performance requirements (minimal level-1 CA interaction)
\end{itemize}


% \noindent \textbf{Protocol Design}
% \begin{itemize}
%     \item Level-1 credential issuance
%     \item Level-2 key derivation and credential issuance
%     \item Verification protocol including accountability checks
%     \item Formal protocol description with all algorithms
% \end{itemize}


\noindent \textbf{Security Analysis}
\begin{itemize}
    \item Security definitions
    \item Proofs for privacy, accountability, Sybil resistance
    \item Comparison with existing approaches
\end{itemize}


\noindent \textbf{Implementation \& Evaluation}
\begin{itemize}
    \item Prototype implementation
    \item Performance measurements
    \item Comparison with other systems
\end{itemize}


Draft Proposed Flow of information
When user gets Level-1 credential (passport):
Gets credential containing their attributes
Also receives a deterministic secret key derived from their Level-1 credential
For Level-2 credential issuance (e.g., driver's license):
User proves possession of valid Level-1 credential to Level-2 issuer
User creates a zero-knowledge proof that their Level-2 public key is derived from their Level-1 secret key
This creates cryptographic link without revealing the actual Level-1 credential


During verification of Level-2 credential:
User proves their credential is valid
If needed, can prove Level-1 credential status without revealing which specific Level-1 credential
Could use techniques like set membership proofs to prove Level-1 credential is not in revocation set

The key would be finding the right cryptographic primitives to:

Create deterministic but unlinkable derivation between Level-1 and Level-2 keys
Allow proving relationship between keys without revealing them
Enable efficient revocation checking


Draft system idea for privately linking credentials
generate randomness: $r = PRF_sk1(level-2-credname)$
generate level2 keypair $sk2 = r, pk2 = g^r $(for a discrete log based keypair example)
Then when verifying level2 credentials, we can tie the accountability back to level1 credentials privately if needed
Private linkage (can't tell which level-1 credential without sk1)
Accountability (can verify level-1 credential status if needed)
No interaction with level-1 CA during level-2 issuance
Deterministic derivation (same user always gets same level-2 key for a given credential name)
Yes exactly! The deterministic derivation of pk2 = $g^PRF_sk1(level-2-credname)$ provides Sybil resistance because:

For a given level-1 credential (with unique sk1) and level-2 credential type (e.g., "drivers-license"), there can only be one possible pk2
The level-2 CA can check if pk2 was already used before issuing a new credential
Users can't create multiple different pk2s for the same level-2 credential type since it's deterministically derived from their level-1 sk1

From the CA's perspective:

They maintain a list of issued pk2s
When a new user requests a level-2 credential, they check if that pk2 exists
If it exists, this user already has this type of credential
If not, it's their first time requesting this credential type

The beauty is:

This Sybil check is done without revealing which level-1 credential the user has
The level-2 CA only needs to track pk2s, not any level-1 credential information
Different level-2 credentials for the same user will have different, unlinkable pk2s due to different credential names in the PRF


\newpage
\subsection{Analysis}
2 methods to privately prove two or more credentials are linked together are proving equality of attributes within commitments and proving that a Level2 credential contains a derivation of the Level1 credential, linking the two together in a hierarchy. 
We asymptotically compare the 2 approaches modelled using Pedersen Commitments and Sigma Protocols as used in many popular Anonymous Credential schemes.

\begin{itemize}
    \item Equality proof method using $Com_1([pid],r_1)$ and $Com_2([pid,ctx],r_2)$
    \item Derivation proof method using $Com_1([pid],r_1)$ and $Com_2([prf(pid,ctx),ctx],r_2)$
\end{itemize}

While proving equality between commitments does not add additional overhead, proving derivation requires additional Prover and Verifier work scaling linearly with respect to the number of credentials being verified
\begin{itemize}
    \item \textbf{Prover:} 3 exponentiation in $\G_1$, 5 add/mul in $\F_p$, 1 inverse operation in $\F_p^{inv}$ and 1 additional commitment $Com$
    \item \textbf{Verifier:} 2 exponentiations in $\G_1$, 3 add/mul in $\F_p$
\end{itemize}

\subsubsection{Equality of committed string}
This method uses sigma protocol with the same challenge $c$ to prove the response $z_{pid}$ can be used to prove knowledge of the opening of both commitments and thus the string must be the same.
\[
ZKP
    \left\{ 
    (pid, r_1, r_2): Com_1 = g_1^{pid} h^{r_1} \wedge Com_2 = g_1^{pid} h^{r_2}
    \right\}
\]

\pcb{
\textbf{User} \< \< \textbf{Verifier}  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
pid, r1, r2 \<\< Com_1, Com_2 \\
a, \rho_1, \rho_2 \sample \mathbb{Z}_q^3 \<\< \\
T_1 := g_1^a h^{\rho_1} \<\< \\
T_2 := g_1^a h^{\rho_2} \< \sendmessageright*{T_1, T_2} \< \\
\< \sendmessageleft*{c} \< c \sample \mathbb{Z}_q \\
z_{pid} = a + c \cdot pid \<\< \\
z_{r_1} = \rho_1 + c \cdot r_1 \<\< \\
z_{r_2} = \rho_2 + c \cdot r_2 \<\< \\
\< \sendmessageright*{z_{pid}, z_{r1}, z_{r2}} \< \\
\<\< g_1^{z_{pid}} h^{z_{r_1}} \stackrel{?}{=} Com_1^c \cdot T_1 \\
\<\< g_1^{z_{pid}} h^{z_{r_2}} \stackrel{?}{=} Com_2^c \cdot T_2 \\
}

\begin{itemize}
    \item Proving knowledge of openings $(pid, r1)$ and $(pid, r2)$ for commitments $Com1 = g_1^{pid}h^{r1}$ and $Com2 = g_1^{pid}h^{r2}$
    \item Proves equality of $pid$ across both commitments
\end{itemize}



\newpage
\subsubsection{Proving derivation of $PRF(x) \to y$}
We use the Dodis Yampolskiy PRF, given the PRF key $pid$ and input $ctx$ $y \gets PRF_{pid}(ctx)$. Algebraically, the output is $y = g^{\frac{1}{pid + ctx}}$. For this protocol, we refer $w := {\frac{1}{pid + ctx}}$ and thus $y = g^w$. We create a sigma protocol to prove knowledge showing $pid$ from $Com_1$ and $ctx$ from $Com_2$ is used for the output $y$. 

\[
ZKP
    \left\{ 
    \begin{aligned}
    (pid, ctx, &w, r_1, r_2, r_3, r_4): \\
    Com_1 &= g_1^{pid} h^{r_1} \wedge \\
    Com_2 &= g_2^{ctx}g_3^{w} h^{r_2} \wedge  \\
    Com_3 &= g_3^{(pid + ctx)} h^{r_3} \wedge \\
    Com_4 &= g_1^{pid}g_2^{ctx}g_3h^{r_1 + r_2 + r_3} \wedge \\
    w \cdot (pid + ctx) &= 1
    \end{aligned}
    \right\}
\]

\pcb{
Prover[] \< \< \textbf{Verifier}  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
pid, ctx, w, r_1, r_2, r_3 \<\< Com_1, Com_2, Com_3, Com_4 \\
\text{where } w = 1/(pid + ctx) \<\< \\
\alpha_1, \alpha_2, \alpha_3, \rho_1, \rho_2, \rho_3 \sample \mathbb{Z}_q^6 \<\< \\
T_1 := g_1^{\rho_1} h^{\alpha_1} \<\< \\
T_2 := g_2^{\rho_2} g_3^{\rho_3} h^{\alpha_2} \<\< \\
T_3 := g_3^{\rho_1 + \rho_3} h^{\alpha_3} \<\< \\
T_4 := g_1^{\rho_1}g_2^{\rho_2}g_3^1h^{\alpha_1 + \alpha_2 + \alpha_3} \<\< \\
\< \sendmessageright*{T_1, T_2, T_3, T_4} \< \\
\< \sendmessageleft*{c} \< c \sample \mathbb{Z}_q \\
z_{pid} = \rho_1 + c \cdot pid \<\< \\
z_{ctx} = \rho_2 + c \cdot ctx \<\< \\
z_{w} =   \rho_3 + c \cdot w \<\< \\
z_{r_1} = \alpha_1 + c \cdot r_1 \<\< \\
z_{r_2} = \alpha_2 + c \cdot r_2 \<\< \\
z_{r_3} = \alpha_3 + c \cdot r_3 \<\< \\
\< \sendmessageright*{z_{pid}, z_{ctx}, z_w, z_{r1}, z_{r2}, z_{r3}} \< \\
\<\< g_1^{z_{pid}} h^{z_{r1}} \stackrel{?}{=} Com_1^c \cdot T_1 \wedge\\
\<\< g_2^{z_{ctx}} g_3^{z_{w}} h^{z_{r2}} \stackrel{?}{=} Com_2^c \cdot T_2 \wedge\\
\<\< g_3^{z_{pid} + z_{ctx}} h^{z_{r3}} \stackrel{?}{=} Com_3^c \cdot T_3 \wedge\\
\<\< g_1^{z_{pid}} g_2^{z_{ctx}} g_3 h^{z_{r_1} + z_{r2} + z_{r3}} \stackrel{?}{=} Com_4^c \cdot T_4 \wedge \\
\<\< Com_4 = Com_1 \cdot Com_2 \cdot Com_3
}

\paragraph{Correctness}
The prover wants to prove knowledge of $pid$ and $ctx$ and that the PRF value $w$ is correctly computed as  $w = \frac{1}{pid + ctx}$.

\[
    \begin{aligned}
        g_1^{z_{pid}} h^{z_{r1}} \stackrel{?}{=}& \; Com_1^c \cdot T_1 \\
        g_1^{\rho_1 + c \cdot pid} h^{\alpha_1 + c \cdot r_1} \stackrel{?}{=}& \; (g_1^{pid} h^{r_1})^c \cdot g_1^{\rho_1} h^{\alpha_1} \\
        g_1^{\rho_1 + c \cdot pid} h^{\alpha_1 + c \cdot r_1} \stackrel{}{=}& \; g_1^{\rho_1 + c \cdot pid} h^{\alpha_1 + c \cdot r_1}\\
    \end{aligned}
\]

\[
    \begin{aligned}
      g_2^{z_{ctx}} g_3^{z_{w}} h^{z_{r2}} \stackrel{?}{=}& \; Com_2^c \cdot T_2 \\
      g_2^{\rho_2 + c \cdot ctx} g_3^{\rho_3 + c \cdot w} h^{\alpha_2 + c \cdot r_2} \stackrel{?}{=}& \; (g_2^{ctx}g_3^{w} h^{r_2})^c \cdot g_2^{\rho_2} g_3^{\rho_3} h^{\alpha_2} \\
      g_2^{\rho_2 + c \cdot ctx} g_3^{\rho_3 + c \cdot w} h^{\alpha_2 + c \cdot r_2} \stackrel{}{=}& \; g_2^{\rho_2 + c \cdot ctx} g_3^{\rho_3 + c \cdot w} h^{\alpha_2 + c \cdot r_2} \\
    \end{aligned}
\]

\[
    \begin{aligned}
      g_3^{z_{pid} + z_{ctx}} h^{z_{r3}} \stackrel{?}{=}& \; Com_3^c \cdot T_3 \\
      g_3^{\rho_1 + c \cdot pid + \rho_2 + c \cdot ctx} h^{\alpha_3 + c \cdot r_3} \stackrel{?}{=}& \; (g_3^{(pid + ctx)}h^{r_3})^c  \cdot g_3^{\rho_1 + \rho_3} h^{\alpha_3} \\
      g_3^{c (pid + ctx) + \rho_1 + \rho_2} h^{\alpha_3 + c \cdot r_3} \stackrel{?}{=}& \; (g_3^{c(pid + ctx)}h^{c \cdot r_3})  \cdot g_3^{\rho_1 + \rho_3} h^{\alpha_3} \\
      g_3^{c (pid + ctx) + \rho_1 + \rho_2} h^{\alpha_3 + c \cdot r_3} \stackrel{?}{=}& \; g_3^{c (pid + ctx) + \rho_1 + \rho_2} h^{\alpha_3 + c \cdot r_3} \\
    \end{aligned}
\]

\[
    \begin{aligned}
      g_1^{z_{pid}} g_2^{z_{ctx}} g_3 h^{z_{r2} + z_{r3}} \stackrel{?}{=}& \; Com_4^c \cdot T_4 \\
      g_1^{\rho_1 + c \cdot pid} g_2^{\rho_2 + c \cdot ctx} g_3 h^{\alpha_2 + c \cdot r_2 + \alpha_3 + c \cdot r_3} \stackrel{?}{=}& \; (g_1^{pid}g_2^{ctx}g_3h^{r_2 + r_3})^c \cdot g_1^{\rho_1}g_2^{\rho_2}g_3h^{\alpha_2 + \alpha_3}\\
      g_1^{\rho_1 + c \cdot pid} g_2^{\rho_2 + c \cdot ctx} g_3 h^{c (r_2 + r_3) + \alpha_2 + \alpha_3 } \stackrel{?}{=}& \; (g_1^{c \cdot pid}g_2^{c \cdot ctx}g_3h^{c (r_2 + r_3)}) \cdot g_1^{\rho_1}g_2^{\rho_2}g_3h^{\alpha_2 + \alpha_3}\\
    \end{aligned}
\]

It has been proven that $Com_1$ opens with $pid$ and $Com_2$ opens with $w$ and $ctx$ and $Com_3$ opens with both $pid + ctx$. $g_3$ is used for both $w$ and $pid + ctx$.
\[
    \begin{aligned}
        Com_4 =& Com_1 \cdot Com_2 \cdot Com_3 \\
        g_1^{pid}g_2^{ctx}g_3h^{r_1 + r_2 + r_3} =& (g_1^{pid} h^{r_1}) \cdot (g_2^{ctx}g_3^{w} h^{r_2}) \cdot (g_3^{(pid + ctx)}h^{r_3}) \\
        g_1^{pid}g_2^{ctx}g_3h^{r_1 + r_2 + r_3} =& g_1^{pid}g_2^{ctx}g_3^{\frac{1}{(pid + ctx)}}g_3^{(pid + ctx)} h^{r_1}h^{r_2}h^{r_3}\\
        g_1^{pid}g_2^{ctx}g_3h^{r_1 + r_2 + r_3} =& g_1^{pid}g_2^{ctx}g_3h^{r_1}h^{r_2}h^{r_3}\\
    \end{aligned}
\]

