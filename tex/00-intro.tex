\section{Abstract}
Main Research Question: 

\textit{How can credential systems be designed to maintain accountability and sybil resistance with privacy and unlinkability. }

\noindent Sub Research Questions

\textit{How can we design a privacy-preserving credential system that enables hidden linking of government and private credentials while maintaining provable provenance and revocability?}

\textit{How can we efficiently combine credentials for verification while retaining their security properties}

\newpage
\section{Intro}
In this section, we discuss the sub-problem:
\textit{How can we design a privacy-preserving credential system that enables hidden linking of government and private credentials while maintaining provable provenance and revocability?}



% When answering, discuss how they motivate, in which setting and why it’s important, and what they’re missing / outstanding work.
% – How used / important is "certified sampling" ?
% – How is it done (if it exists) ?

% Motivation
% https://eprint.iacr.org/2024/1124.pdf#page=14.48
% https://pages.nist.gov/800-63-4/sp800-63c.html

\subsection{Motivation}


% \paragraph{Internet Identity Workshop}

The Internet Identity Workshop discussed a problem space summarised by the following problems:
\begin{enumerate}
    \item issuing credentials that are both government and privately issued
    \item retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
    \item combining traditional digital identity with decentralized identity
\end{enumerate}

A user has an Identity linked to multiple credentials, such as a driver's license and university card. Users want to authenticate with various Relying Parties (Verifiers) without being linked between multiple uses of the same service (e.g. a user verifying multiple credentials with 1 service such as a bank requiring proof of multiple credentials linked to an identity), and between uses of different services (e.g. a user presenting their drivers license for age verification on multiple services).

Current decentralized identity systems either don't provide this functionality or provide it at the expense of either accountability or privacy. CanDID stores a map between users multi-layered credentials providing a solution to the problem at the expense of the user's privacy. Other credential systems and pseudonym systems prove equality of hidden attributes in a credential such as name or id, which can more-easily be forged and does not support the hierarchical structure leveraging a highly secure and accountable government identity with not-so secure private credentials.

\newpage




\section{Related Work}
\textbf{Decentralized Identity}
In DID, a user has multiple credentials in a "digital wallet" and decides how to use them and which information can be revealed. The credentials are issued to an individuals identifier and publicly verified on a decentralized system, improving interoperability and aiming to break from the platform lock-in effects of the current centralized identity systems. Unlike using physical credentials, this provides a unique step-forwards in digital identity management as organizations can verify a user's information more thoroughly at a wider breadth. E.g. multiple credentials from different issuers, preventing the use of credential theft from a single credential. DID has made great progress towards its goals of decentralizing identity management from single providers like Google and Microsoft with projects like DID foundation, Sovrin, W3C. However, at the expense of Privacy.

\noindent \textbf{Anonymous Credentials}
Anonymous Credentials are a long line of orthogonal work with the goal of providing privacy/anonymity to online interactions, These are now deployed in a number of real-world systems (U-Prove, Idemix, PrivacyPass).  
The line of work has improved with features, efficiency, and expressiveness throughout time. 
Abstractly, they provide private protocols to prove information on committed attributes. 
Pairing-based blind signatures enabled efficient multi-show credentials (CL, PS, BBS+).
Other constructions are based on (chase's MAC's, etc) 
Further work was done to the Anonymous Credential primitive to support delegation, update, and pseudonyms and may also require incorporating other cryptographic primitives to enable revocation, auditing, tracing, and sybil resistance. 

\noindent \textbf{Accountable Privacy}
In a parallel industry, fully private financial systems like zcash, monero, and tornado cash where blockchain users can exploit and misuse the system is a big problem and will prevent governments and organisations to deploy private preserving techniques. Innovations in Identity often follow those in financial systems, (Chaum's e-cash and blind signatures, DAC and ZCash for example) as they share similar motivations and infrastructure, spending a coin anonymously is analogous to using an identity anonymously. Therefore, advancements in the field of Accountable Privacy (UTT, other examples), a series of techniques and protocols that balance the tradeoffs between privacy and accountability in financial systems, can inspire and motivate private identity systems.

\noindent \textbf{Decentralized Identity with Anonymous Credentials}
The strawman approach to combining Decentralized Identity with Anonymous Credentials replaces the existing credential, usually in the form of a signature over attributes, signed by an identity provider and verifiable with their public key, with a blind signature over attributes, which introduces the accountable privacy problems such as how to issue and verify a credential to an anonymous user, and how to retain accountability of an anonymous user, such are the real-world identity system requirements. 
Compatibility for a decentralized architecture requires decentralized cryptography which has propelled the use of threshold cryptography in anonymous credential schemes and other settings e.g. (Coconut, Threshold BBS+, ...). 

\noindent \textbf{Privacy Preserving Decentralized Identity Systems}
CanDID proposed a privacy-preserving decentralized identity system achieving Sybil Resistance, Accountability
\begin{enumerate}
    \item Achieves sybil resistance but at the expense of using heavy MPC
    \item Requires interacting with the committee for issuing each Context Credential
    \item maintain a mapping of users credentials to real-world identity (scalability, privacy, security concern)
    \item Interacting with the committee links different transactions because the credentials rely on public keys and each committee member holds a list of the links between master public key and context credential public key
    \item maintains a (state) mapping between credentials and real-world identities, introducing scale issues and dependencies
    \item The master credential can be used maliciously to get context credentials because there is no key derivation between master and context
\end{enumerate} 

\noindent \textbf{An Identity with Multiple Credentials}
\todonote{Motivate the problem - what functionality do we achieve without privacy - what do we lose when we introduce it}

Previous Methods
- CanDID is not private but efficient, but stores a mapping
- unclonable group identification (noted from Syra) achieves this
- traceable ring signatures does something better than that (see syra page 2)

\noindent SyRA: Sybil-Resilient Anonymous Signatures  with Applications to Decentralized Identity \cite{crites_syra_2024}
1. enables users to "derive" unlinkable, sybil resistant pseudonyms (signatures) for a context e.g. PRF(sk, ctx) without interacting with the issuer
2. does not store a mapping on the issuer
3. Security properties: Sybil resistance in the context. Anonymity: no information is leaked through their nyms or signatures. Proves UC security for unforgeability, Sybil resilience, privacy, and unlinkability
4. SyRA leaves support for Identity Attributes for future work.
Summary: First, a protocol with issuer creates a user with secret key $s$. $s$ generates a context specific pseudonym, or tag $T$ "that attaches itself to a signature"?

\begin{itemize}
    \item Level 1: $VRF_{isk}(s) \to T, \pi_{prf}$ such that $\pi_{prf}$ generates the users keys and is symmetric across $\G_1, \G_2$: This algorithm is computed by the issuer with their secret key $isk$ on identity string $s$ Outputs $T = e(g, \tilde{g})^{1/(s + isk)}$ and $\pi_{prf}$ is $upk = g^{1/(s + isk)} \in \G_1$ and $\widehat{usk} = \tilde{g}^{1/(s + isk)} \in \G_2$. Their verify algorithm is the same as the Dodis Yampolskiy and also verifies the asymmetric keys with bilinear pairing.
    \item Level 2: $VUF_{usk}(ctx) \to T = e(H(ctx), \widehat{usk})$: This is the "sybil resistant signature". Proof of correctness comes from sigma protocol. During the verify protocol, the 
\end{itemize}





Attribute-Based Threshold Issuance Anonymous Counting Tokens \cite{rabaninejad_attribute-based_nodate}


What don't they do that we do?
We avoid Groth Sahai proofs - page 26 they refer to proving the signature scheme with GS proofs. 
They use Naor Pinkas Reingold PRF and verify signature with GS proofs. 
They focus only on deriving credentials / pseudonyms from their


\subsection{Comparison}

\begin{table}
\begin{center}
\caption{Comparison of our construction over CanDID identity system.}
\label{tab:comparison}
\begin{tabular}{l|ccccccc}
Features    & ABC$\footnotemark[1]$.          & unf.          & blind.                & Sybil-resistance  & unlink.       & non-transfer. & non-interact $\ddagger$ \\
\hline
CanDID      & \ding{55}     & \ding{51}     & \ding{51}$\footnotemark[2]$   & \ding{51}         & \ding{55}     & \ding{55}     & \ding{55}  \\
SyRA        & \ding{55}     & \ding{51}     & \ding{51}             & \ding{51}         & \ding{51}     & \ding{51}     & \ding{51}  \\
S3ID        & \ding{51}     & \ding{51}     & \ding{51}             & \ding{51}         & \ding{51}     & \ding{51}     & \ding{51}  \\
US          & \ding{51}     & \ding{51}     & \ding{51}             & \ding{51}         & \ding{51}     & \ding{51}     & \ding{51}  \\
\end{tabular}
\end{center}

\vspace{1em}
\footnotesize
$\footnotemark[1]$ Attribute Based Credentials

\footnotesize
$\footnotemark[2]$ CanDID is pseudonymous rather than being fully anonymous; i.e., the issuer learns a unique pseudonym as the identifier of a user who initiates each query and is associated with that user's CanDID credentials.

\footnotesize
$\footnotemark[3]$ This property is with respect to the AppCred phase. Dedup and MicroCred phases are intrinsically interactive, akin to the CanDID system.
\end{table}





Attribute-based credentials



"1. Write comparison table of Anonymous Credential systems including threshold issuance, sybil resistance, revocation, pseudonyms/multiple credentials"

threshold issuance/decentralized
sybil resistance
revocation
pseudonyms/multiple credentials
Anonymous Credentials (unlinkable, multi-show, selective disclosure, non-transferrable)











\subsection{Concurrent Work}
Identity Providers (IdP's)/SSO systems enable a user with a single identity (uid) to login to multiple services called Relying Parties (RP). User's wanting to authenticate with an RP are redirected to the IdP to login, the IdP then sends a cryptographic token to the RP attesting to the user's permission to login, sharing user identifier uid and optionally user attributes.
\textbf{Unlinkability:} To prevent different RP's from tracking the user's uid (a privacy problem), pairwise pseudonyms were proposed, and recommended by NIST to improve user privacy, and currently used by Apple's SSO service. Pairwise pseudonyms create a new problem - the record of user id uid and pairwise id ppid needs to be stored on the IdP on a central service and accessed for each login request and therefore every authentication request can be tracked by the IdP. 

OpenID Connect (OIDC) supports pairwise pseudonyms by setting $ppid = H(k, uid, rid)$ where H is a hash function, $k$ is a random key and $rid$ is the relying party. During login, the IdP generates ppid and stores it, then sends $ppid$ instead of $uid$ to the RP. User's cannot generate more than 1 ppid and thus \textbf{pseudonym Sybil Resistance} is upheld. 

Observability is defined by the notion that each authentication request from a relying party RP to the IdP enables IdP to observe the user's identity usage. Furthermore, to prevent reply attacks, the IdP includes RP specific information in the authentication token to prevent multiple uses or uses for the wrong RP.

OPPID \cite{kroschewski_oppid_2024} supports unlinkability (across relying parties), sybil resistance (for each context) and unobservability (which prevents the IdP from learning each RP the user interacts while retaining their requirement to bind their login token to an RP). OPPID enhances privacy in pseudonym login tokens by hiding which RP is being used while retaining existing security requirements.








































\newpage
\subsection{Hierarchical Credentials}

The user's Level-1 credential forms the root of trust.
We want a way to privately prove Level-1 credentials are valid when using Level-2 credentials, when the attributes in each credential are different. We want to allow verification of Level-1 credential status without revealing which Level-1 credential it is, maintain revocation across levels.
\begin{itemize}
    \item \textbf{Level-1 (High Security):} Government issues passport credentials using secure threshold infrastructure (foundational identity credentials for users)
    \item \textbf{Level-2 (Lower Security):} Organisations like DMV, Universities, Running their own credential infrastructure. Want to privately link users to Level-1 Credential for accountability and higher security (borrowing security from Level-1). If a Level-1 credential is revoked, level-2 can borrow it's revocation
\end{itemize}

The problem I'm addressing
\begin{enumerate}
    \item creating a hierarchical credential system where high-security credentials (Level-1, like passports) can be linked to lower security credentials (Level-2, like driver's license)
    \item Solving the privacy vs accountability trade-off that exists in current systems like CanDID
\end{enumerate}

Novel Contribution
\begi
n{enumerate}
    \item Privacy-Preserving link between credential levels using deterministic key derivation
    \item Efficient and Private system design which doesn't require Level-1 CA interaction for Level-2 Credentials. Maintains privacy for Level-1 Credentials, enables accountability and Sybil Resistance
    \item Zero-Knowledge Proof System allowing credential verification and proof of correct link between credentials, selective disclosure, revocation checking across levels
\end{enumerate}


\subsection{Related Works}
\begin{itemize}
    \item CanDID Decentralized Identity records the state i.e. (level1-pk, level2-pk) on the level1 ca. This is not private and requires interacting with level-1 for each credential issued which isn't good because it will overwhelm level-1 ca.

    \item OpenID, Apple SSO, IdP

    \item Commitment Equality

    \item Link-G16

    \item Anonymous Payment Systems are analogous to Private Identity Systems
    
\end{itemize}



Draft Proposed Flow of information
When user gets Level-1 credential (passport):
Gets credential containing their attributes
Also receives a deterministic secret key derived from their Level-1 credential
For Level-2 credential issuance (e.g., driver's license):
User proves possession of valid Level-1 credential to Level-2 issuer
User creates a zero-knowledge proof that their Level-2 public key is derived from their Level-1 secret key
This creates cryptographic link without revealing the actual Level-1 credential


During verification of Level-2 credential:
User proves their credential is valid
If needed, can prove Level-1 credential status without revealing which specific Level-1 credential
Could use techniques like set membership proofs to prove Level-1 credential is not in revocation set

The key would be finding the right cryptographic primitives to:

Create deterministic but unlinkable derivation between Level-1 and Level-2 keys
Allow proving relationship between keys without revealing them
Enable efficient revocation checking


Draft system idea for privately linking credentials
generate randomness: $r = PRF_sk1(level-2-credname)$
generate level2 keypair $sk2 = r, pk2 = g^r $(for a discrete log based keypair example)
Then when verifying level2 credentials, we can tie the accountability back to level1 credentials privately if needed
Private linkage (can't tell which level-1 credential without sk1)
Accountability (can verify level-1 credential status if needed)
No interaction with level-1 CA during level-2 issuance
Deterministic derivation (same user always gets same level-2 key for a given credential name)
Yes exactly! The deterministic derivation of pk2 = $g^PRF_sk1(level-2-credname)$ provides Sybil resistance because:

For a given level-1 credential (with unique sk1) and level-2 credential type (e.g., "drivers-license"), there can only be one possible pk2
The level-2 CA can check if pk2 was already used before issuing a new credential
Users can't create multiple different pk2s for the same level-2 credential type since it's deterministically derived from their level-1 sk1

From the CA's perspective:

They maintain a list of issued pk2s
When a new user requests a level-2 credential, they check if that pk2 exists
If it exists, this user already has this type of credential
If not, it's their first time requesting this credential type

The beauty is:

This Sybil check is done without revealing which level-1 credential the user has
The level-2 CA only needs to track pk2s, not any level-1 credential information
Different level-2 credentials for the same user will have different, unlinkable pk2s due to different credential names in the PRF

\newpage
\section{Issuing}
Write about the registration setting, how a user with a master credential 

\newpage
\section{Usage}
2 methods to privately prove two or more credentials are linked together are proving equality of attributes within commitments and proving that a Level2 credential contains a derivation of the Level1 credential, linking the two together in a hierarchy. 
We asymptotically compare the 2 approaches modelled using Pedersen Commitments and Sigma Protocols as used in many popular Anonymous Credential schemes.

\todonote{update the below with all methods}
While proving equality between commitments does not add additional overhead, proving derivation requires additional Prover and Verifier work scaling linearly with respect to the number of credentials being verified
\begin{itemize}
    \item \textbf{Prover:} 3 exponentiation in $\G_1$, 5 add/mul in $\F_p$, 1 inverse operation in $\F_p^{inv}$ and 1 additional commitment $Com$
    \item \textbf{Verifier:} 2 exponentiations in $\G_1$, 3 add/mul in $\F_p$
\end{itemize}How many Exponen

\begin{itemize}
    \item Equality proof method using $Com_1([m],r_1)$ and $Com_2([m,ctx],r_2)$
    \item Derivation proof method using $Com_1([m],r_1)$ and $Com_2([prf(m,ctx),ctx],r_2)$
\end{itemize}


\subsubsection{Equality of committed string}
This method uses sigma protocol with the same challenge $c$ to prove the response $z_{pid}$ can be used to prove knowledge of the opening of both commitments and thus the string must be the same.
\[
ZKP
    \left\{ 
    (pid, r_1, r_2): Com_1 = g_1^{pid} h^{r_1} \wedge Com_2 = g_1^{pid} h^{r_2}
    \right\}
\]

\pcb{
\textbf{User} \< \< \textbf{Verifier}  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
pid, r1, r2 \<\< Com_1, Com_2 \\
a, \rho_1, \rho_2 \sample \mathbb{Z}_q^3 \<\< \\
T_1 := g_1^a h^{\rho_1} \<\< \\
T_2 := g_1^a h^{\rho_2} \< \sendmessageright*{T_1, T_2} \< \\
\< \sendmessageleft*{c} \< c \sample \mathbb{Z}_q \\
z_{pid} = a + c \cdot pid \<\< \\
z_{r_1} = \rho_1 + c \cdot r_1 \<\< \\
z_{r_2} = \rho_2 + c \cdot r_2 \<\< \\
\< \sendmessageright*{z_{pid}, z_{r1}, z_{r2}} \< \\
\<\< g_1^{z_{pid}} h^{z_{r_1}} \stackrel{?}{=} Com_1^c \cdot T_1 \\
\<\< g_1^{z_{pid}} h^{z_{r_2}} \stackrel{?}{=} Com_2^c \cdot T_2 \\
}

\begin{itemize}
    \item Proving knowledge of openings $(pid, r1)$ and $(pid, r2)$ for commitments $Com1 = g_1^{pid}h^{r1}$ and $Com2 = g_1^{pid}h^{r2}$
    \item Proves equality of $pid$ across both commitments
\end{itemize}





\newpage
\section{ZKP Contribution 15/11}
\subsection{The setting}
\todonote{introduce the setting}


\subsection{ZKP Sigma Protocol for proving PRF output in G1}
We have $g^{\frac{1}{m}}$ and $g^m$. We want to prove their relationship is reciprocal. We will use this later when proving the output of the Dodis Yampolskiy VRF $g^{\frac{1}{sk + x}}$
Let $m_1 = m$, and $m_2 = \frac{1}{m}$. Therefore, we can prove that $m_1 \cdot m_2 = 1$ 
\[ 
    \begin{aligned}
        C_1 &= g^{m_1}h^{r_1} \\
        C_2 &= g^{m_2}h^{r_2} \\
        C_3 &= C_1^{m_2}h^{r_3} \\ 
        C_4 &= h^{r_1m_2 + r_3} \\ 
    \end{aligned}
\]

We use $C_1, C_2$ in a zero-knowledge proof protocol to prove the relation with public elements $C_1, C_2, g, h$

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1
    \right\}
\]

\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g^{m_1}h^{r_1}, C_2 = g^{m_2}h^{r_2}$} \\
{\{\rho_i\}_{i=1}^4, \{\beta_i\}_{i=1}^2}  \sample \mathbb{Z}_q^6 \<\< \\
T_1 \gets g^{\beta_1}h^{\rho_1} \<\< \\
T_2 \gets g^{\beta_2}h^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
C_3 \gets C_1^{m_2}h^{r_3} \<\< \\
T_3 \gets C_1^{\beta_2}h^{\rho_3} \<\< \\
r_4 \gets r_1m_2 + r_3 \<\<  \\
C_4 \gets h^{r4} \<\< \\
T_4 \gets h^{\rho_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
z_{m1} = \beta_1 + e \cdot m_1 \<\< \\
z_{r1} = \rho_1 + e \cdot r_1 \<\< \\
z_{m2} = \beta_2 + e \cdot m_2 \<\< \\
z_{r2} = \rho_2 + e \cdot r_2 \<\< \\
z_{r3} = \rho_3 + e \cdot r_3 \<\< \\
z_{r4} = \rho_4 + e \cdot r_4 \<\< \\
\< \sendmessageright*{\{z_{mi}\}_{i=1}^2, \{z_{ri}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g^{z_{m1}} h^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g^{z_{m2}} h^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  C_1^{z_{m2}} h^{z_{r3}}\\
\<\< C_4^e \cdot T_4 \stackrel{?}{=}  h^{z_{r4}}\\
\<\< C_3/C_4 = g \\
}

\subsubsection{Completeness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$ 
\begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag 
\end{align}

Proof of knowledge of exponents $m2, r2$ by opening $C_2$ 
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} g^{z_{m2}} h^{z_{r2}} && \label{eq:ver1} \\
    (g^{m2}h^{r_2})^e \cdot g^{\beta_2}h^{\rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag \\
    g^{e \cdot m2 + \beta_2}h^{e \cdot r_2 + \rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag 
\end{align}


Equality of $m2 \in \{C_2, C_3\}$ proven by equality of responses $g^{z_{m2}}$ used in \eqref{eq:ver1} and \eqref{eq:ver2}
\begin{align}
    C_3^e \cdot T_3 &\stackrel{?}{=} C_1^{z_{m2}} h^{z_{r3}} \notag \\
    (C_1^{m2}h^{r_3})^e \cdot C_1^{\beta_2}h^{\rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \label{eq:ver2} \\
    C_1^{m2 \cdot e + \beta_2}h^{e \cdot r_3 + \rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \notag
\end{align}

Proof of knowledge of exponent $r4$ by opening $C_4$ 
\begin{align}
    C_4^e \cdot T_4 &\stackrel{?}{=} h^{z_{r4}} \notag \\
    (h^{r_4})^e \cdot h^{\rho_4} &\stackrel{?}{=} h^{\rho_4 + e \cdot r_4} \notag \\
    h^{e \cdot r_4 + \rho_4} &= h^{\rho_4 + e \cdot r_4} \notag
\end{align}

Prove that $C_3/C_4 = g$ implies $g^{\frac{m1}{m2}} = 1$ which proves their inverse relation. Recall $C_1 = g^{m_1}h^{r_1}, r_4 = r_1m_2 + r_3$
\begin{align}
    \dfrac{C_3}{C_4} = \dfrac{C_1^{m2}h^{r_3}}{h^{r_4}} = \dfrac{(g^{m_1}h^{r_1})^{m2}h^{r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g^{m_1\cdot m2}h^{r_1\cdot m2 + r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g}{1} = g \notag \\
\end{align}

\subsubsection{Soundness}

\subsubsection{Zero Knowledge}

\subsubsection{Analysis}

\todonote{Update the below with real analysis}
\begin{itemize}
    \item \textbf{Prover:} 3 exponentiation in $\G_1$, 5 add/mul in $\F_p$, 1 inverse operation in $\F_p^{inv}$ and 1 additional commitment $Com$
    \item \textbf{Verifier:} 2 exponentiations in $\G_1$, 3 add/mul in $\F_p$
\end{itemize}How many Exponen



\subsection{ZKP Sigma Protocol for proving PRF output with pairing}

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g_1^{m_1}h_1^{r_1} \in \G_1 \wedge C_2 = g_2^{m_2}h_2^{r_2} \in \G_2 \wedge m_1 \cdot m_2 = 1
    \right\}
\]


\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g_1^{m_1}h_1^{r_1}, C_2 = g_2^{m_2}h_2^{r_2}$ } \\
{\{\rho_i\}_{i=1}^2, \{\beta_i\}_{i=1}^2, \{\gamma_i\}_{i=1}^4}  \sample \mathbb{Z}_q^8 \<\< \\
T_1 \in \G_1 \gets g_1^{\beta_1}h_1^{\rho_1} \<\< \\
T_2 \in \G_2 \gets g_2^{\beta_2}h_2^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
\alpha_1 \gets m_1 \cdot m_2 \<\< \\
\alpha_2 \gets m_1 \cdot t_2 \<\< \\
\alpha_3 \gets t_1 \cdot m_2 \<\< \\
\alpha_4 \gets t_1 \cdot t_2 \<\< \\
A_1 \gets e(g_1, g_2) \<\< \\
A_2 \gets e(g_1, h_2) \<\< \\
A_3 \gets e(h_1, g_2) \<\< \\
A_4 \gets e(h_1, h_2) \<\< \\
\pclinecomment{$C_3 = e(C_1, C_2)$} \\
C_3 \in \G_T \gets A_1^{\alpha_1} A_2^{\alpha_2} A_3^{\alpha_3}  A_4^{\alpha_4}\<\< \\
T_3 \in \G_T \gets  A_1^{\gamma_1} A_2^{\gamma_2} A_3^{\gamma_3} A_4^{\gamma_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^3, \{A_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
z_{m1} = \beta_1 + e \cdot m_1 \<\< \\
z_{r1} = \rho_1 + e \cdot r_1 \<\< \\
z_{m2} = \beta_2 + e \cdot m_2 \<\< \\
z_{r2} = \rho_2 + e \cdot r_2 \<\< \\
z_{a1} = \gamma_1 + e \cdot \alpha_1 \<\< \\
z_{a2} = \gamma_2 + e \cdot \alpha_2 \<\< \\
z_{a3} = \gamma_3 + e \cdot \alpha_3 \<\< \\
z_{a4} = \gamma_4 + e \cdot \alpha_4 \<\< \\
\< \sendmessageright*{\{z_{mi}\}_{i=1}^2, \{z_{ai}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g_1^{z_{m1}} h_1^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g_2^{z_{m2}} h_2^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  A_1^{z_{a1}}A_2^{z_{a2}}A_3^{z_{a3}}A_4^{z_{a4}}\\
\<\< 
}























































\section{Methods}


% Let $a : \N \mapsto \N \bigcup \{*\}$ and $b : \N \mapsto \N$ be any functions for which $a(\lambda)$ and $b(\lambda)$ are computable in $poly(\lambda)$ time (expect when $a$ takes value $*$).
% % \begin{definition}
% %     A function family $F_{(\cdot)}(\cdot) : \bit^{a(\lambda)} \mapsto \bit^{b(\lambda)}$ is a family of $VRFs$ if there exists a PPT algorithm $Gen$ and deterministic algorithms $Prove$ and $Ver$ such that $Gen(\secparam)$ outputs a pair of keys $(sk, pk)$, $Prove_{sk}(x)$ computes $(y, \pi)$ where $\pi$ is the proof of correctness, and $Ver_{pk}(x,y,\pi)$ verifies that $y = e(g,g)^{1/x+sk}$ using the proof $\pi = g^{1/x+sk}$
% % \end{definition}

\subsection{Pseudo Random Function}
We use the properties of a pseudo-random function to derive the relationship between a master and context credential. The pseudorandomness property ensures the output $y$ is computationally indistinguishable from random and thus hides the relationship between the user's secret key $sk$ and an input $x$ which could be the context of the new credential we want to privately link to.
\[
    PRF_{sk}(x) \to y
\]

\begin{definition}[Pseudo Random Function]
    A PRF is a couple of algorithms $(PRF.Gen, f)$ with key space $\setK$, input space $\setX$ and output space $\setY$ such that 
    \begin{itemize}
        \item $Gen(\secparam) \to (sk): s \sample S$, sets $sk = s$
        \item $f:$ $\mathcal{K} \times \mathcal{X} \to \mathcal{Y}$ is a keyed function family
    \end{itemize}
\end{definition}

The main security property of a $PRF$ is pseudorandomness, which informally states the output should appear random and not be able to be guessed. Formally, defined as

\begin{definition}[Pseudorandomness]
    A couple of PPT algorithms $(PRF.Gen, f)$ is a \textit{Pseudo Random Function} if, for any $\PPT$ adversary $\adv$ there exists a negligible function $\epsilon$ such that 
    \[
    \advantage{}{}[(\adv)] := 
        \left|
    \Pr     \left[ 
                \mathsf{Exp}^{\mathsf{prf}}(\adv) = 1
            \right] - \frac{1}{2}
        \right| \leq \epsilon(\lambda)
    \]
\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{prf}}(\adv)$}{%
        b \sample \bit \\
        \text{Sample } k \sample PRF.Gen(1^{\lambda}) \\
        \text{Sample } f^* \sample \{g : g : \mathcal{X} \to \mathcal{Y}\} \\
        \text{Run } b' \gets \adv^{\oracle_{\mathsf{prf}}}(1^{\lambda}) \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{prf}(x)}$}{%
        \pcif b = 1 \\
        \t \pcreturn f_k(x) \\
        \pcelse \\
        \t \pcreturn f^*(x)
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}


\subsection{Verifiable Random Function}

\subsubsection{Syntax}
\begin{itemize}
    \item $Gen(\secparam) \to (sk, pk):$ samples $s \sample \Zp^*$, sets $sk = s$ and $pk \gets g^s$, returns $(sk, pk)$
    \item $Prove_{sk}(x) \to (y, \pi):$ $y \gets e(g,g)^{1/(x+sk)}$, $\pi \gets g^{1/(x+sk)}$ where $y$ is the $PRF$ output and $\pi$ is the proof of correctness
    \item $Verify_{pk}(x, y, \pi) \to \bit$ to verify $y$ was computed correctly, verify $e(g^x \cdot pk, \pi) = e(g,g)$ and $y = e(g, \pi)$, output 1 for success, 0 for fail
\end{itemize}

\begin{definition}[Verifiable Random Function]

    A PRF is a triplet of $\PPT$ algorithms $(VRF.Gen, VRF.Eval, VRF.Vfy)$ satisfying:
    \begin{enumerate}
        \item Correctness: For any $(pk, sk)$ in the image of $VRF.Gen(\secparam)$ and any $x \in \setX$
        \[
        \begin{aligned}
            (y, \pi) &\gets VRF.Eval_{sk}(x) \\
            1 &\gets VRF.Vfy_{pk}(x, y, \pi)
        \end{aligned}
        \]


    \item Unique Provability: For any $pk$ (not necessarily in the range of $VRF.Gen$, any input $x \in \setX$, pair of outputs $y_0, y_1 \in \setY$ and pair of proofs $\pi_0, \pi_1$ the following holds
    \[
        \begin{aligned}
            1 &\gets VRF.Vfy_{pk}(x,y_0,\pi_0) \\
            1 &\gets VRF.Vfy_{pk}(x,y_1,\pi_1) \\
            y_0 &= y_1
        \end{aligned}
    \]

    \item Pseudorandomness: For any $\PPT$ adversary $\adv$ running the VRF Experiment, there exists a negligible function $\epsilon$ such that 
    \[
         \advantage{}{}[(\adv)] := 
            \left|
        \Pr     \left[ 
                    \mathsf{Exp}^{\mathsf{rnd}}(\adv) \to 1
                \right] - \frac{1}{2}
            \right| \leq \epsilon(\lambda)
    \]
    
    \end{enumerate}

\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{eval}}(\adv)$}{%
        \text{Sample } b \sample \bit \\
        pk, sk \sample VRF.Gen(1^{\lambda}) \\
        \text{set } x^* = \bot \\
        x^* \gets \adv^{\oracle_{\mathsf{eval}}}(pk) \\
        \pcif x^* \text{was previously queried:} \\
        \t \pcreturn 0 \\
        y_0 \sample \setY \\
        (y_1, \pi) \gets VRF.Eval(pk, x^*) \\
        \adv^{\oracle_{\mathsf{eval}}}(sk, y_b) \to b' \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{eval}(x)}$}{%
        \pcif x \neq x^* \\
        \t (y, \pi) \gets VRF.Eval_{sk}(x) \\
        \t \pcreturn (y, \pi) \\
        \pcelse: \pcreturn \bot \\
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}